---
title: "Gene Set Analysis (GSEA)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format:
  html:
    embed-resources: true
    code-fold: show
params:
  fig.path: "`r paste0(params$fig.path)`" #./Figures/
  run.gsea: FALSE
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  fig.width     = 6.693,
  fig.path      = params$fig.path,#"../Figures/",
  fig.align     = "center",
  message       = FALSE,
  warning       = FALSE,
  dev           = c("png"),
  dpi           = 300,
  fig.process = function(filename){
    new_filename <- stringr::str_remove(string = filename,
                                        pattern = "-1")
    fs::file_move(path = filename, new_path = new_filename)
    ifelse(fs::file_exists(new_filename), new_filename, filename)
  }
  )
# setwd("/Users/vilkal/work/Brolidens_work/Projects/Spatial_DMPA/src")
```

```{r background_job, eval=FALSE, include=FALSE}
source("../bin/render_with_jobs.R")

# quarto
# render_html_with_job(out_dir = lab_dir)
# fs::file_move(path = file, new_path = paste0(lab_dir, file))

# currently using quarto for github and kniter for html due to source code option 
render_git_with_job(fig_path = "./Figures/07/")
system2(command = "sed", stdout = TRUE,
        args = c("-i", "''","-e", 's/src=\\"\\./src=\\"\\.\\./g',
                 paste0("./md_files/", basename("./07_Gene_set_analysis.md"))))

# kniter
knit_html_with_job(out_dir = "../lab_book/07_GSEA_st_data", fig_path = "./Figures/07/")
```

### Load data and libraries

```{r Load_data}
##################
# LOAD LIBRARIES #
##################
library(tidyverse)
library(Seurat)
library(SeuratObject)
library(tidyseurat)
library(patchwork)
library(ggrepel)
library(ggridges)
library(scales)
library(niceRplots)
library(fgsea)
library(openxlsx)
library(jsonlite)

source("../bin/plotting_functions.R")
source("../../broliden_5325/code/enrichment_function.R")

#########
# PATHS #
#########
input_dir <- "../results/06_DGE_condition_st_data/"
result_dir <- "../results/07_GSEA_st_data/"
if( isFALSE(dir.exists(result_dir)) ) { dir.create(result_dir,recursive = TRUE) }

KEGG_path <- "../resources/c2.cp.kegg_legacy.v2023.2.Hs.json"
GO_path <- "../resources/c5.all.v2023.2.Hs.json"
TFT_path <- "../resources/c3.tft.gtrd.v2023.2.Hs.symbols.gmt"
epi_clus <- "^5$|^6$|^7|^9"
submuc_remove <- "1|2"

#############
# LOAD DATA #
#############
# DEGs_table <- read_csv(paste0(input_dir,"DGEs_condition_wilcox.csv"))
DEGs_table <- readxl::read_xlsx(paste0(input_dir,"Supplemental Table 4.xlsx"), sheet = "DEGs condition")
DATA <- readRDS(paste0("../results/04_deconvolution_st_data/","seuratObj_deconvolution_scdc.RDS"))

read_json.fun <- function(db){
  db <- db %>%
  map(., ~as_tibble(.x[4])) %>%
  bind_rows(., .id = "pathway") %>%
  mutate(db = map(db, ~pluck(.x, "geneSymbols")))
  return(db)}
GO_database <- read_json.fun(fromJSON(GO_path))
KEGG_database <- read_json.fun(fromJSON(KEGG_path))
TFT_database <- fgsea::gmtPathways(TFT_path)

# set seed for all operations
# c <- addTaskCallback(function(...) {set.seed(123);TRUE})
# removeTaskCallback(c)
# sample(1:500, 3)
```

```{r factor}
ord1 <- c("Sup_1","Sup_2","Basal_2","Basal_1","0","1","2","3","4","8","10")
ord2 <- c("6","9","7","5","0","1","2","3","4","8","10")

DEGs_table <- DEGs_table %>%
  mutate(subgroup = factor(.$subgroup, levels = ord2)) %>%
  mutate(layers = factor(.$layers, levels = ord1)) #%>%
  #dplyr::rename(Clusters="layers") 
```

```{r order-by-gene-rank}
####################
# CREATE GENE RANK #
####################
# log.pct.diff , p_val_adj
DEGs_list <- DEGs_table %>% 
  group_split(., subgroup) %>% 
  set_names(., sort(unique(DEGs_table$layers)))

get_gene_rank.fun <- function(DEGs_list, stat = "avg_log2FC"){
  stat <- sym(stat)
  gene_rank_df <- DEGs_list %>%
    map(., ~.x %>%
      select(gene, avg_log2FC) %>%
        mutate(.x, "logFC*p-val" = sign(avg_log2FC) * -log10(p_val))  %>%
        mutate(.x, stat_ord = !!(stat)) %>%
        mutate(.x, spatial_dist = rank(stat_ord)) %>%
        mutate(.x, rank = rank(stat_ord))
        #mutate(.x, statsAdj = sign(stat_ord) * (abs(stat_ord) ^ 1) ) %>%
        #mutate(.x, statsAdj = statsAdj / max(abs(statsAdj))) %>%
  ) %>% map(., ~arrange(.x, desc(stat_ord)))
}
gene_rank_df <- get_gene_rank.fun(DEGs_list, "avg_log2FC")
#gene_rank_df <- get_gene_rank.fun(DEGs_list, "logFC*p-val")

gene_rank_list <- enframe(gene_rank_df) %>%
  mutate(gene_list = pmap(., ~set_names(pull(..2, "stat_ord"), pull(..2, "gene") )) ) %>%
  mutate(gene_list = setNames(.[["gene_list"]], .$name)) %>%
  .$gene_list

# seems faulty, so now I don't trust the GSEA results
# gene_rank_list <- gene_rank_df %>%
#   map(., ~pull(.x, stat_ord)) %>% 
#   map2(., DEGs_list, ~set_names(.x, pull(.y, "gene")))

```

Here is a documentation for GSEA, pointing to Enrichment Scores in particular: https://www.gsea-msigdb.org/gsea/doc/GSEAUserGuideTEXT.htm#*Enrichment_Score*(ES)

And here is one of the clearest and most thorough explanations I've found: https://www.pathwaycommons.org/guide/primers/data_analysis/gsea/

Answering your specific questions:

Larger magnitudes are "better" The sign on the score simply indicates when end of your ranked gene list is enriched. You provide the rank list of genes, so the biiological interpretation is up to you. If, for example, you provide a gene list ranked by a combination of fold change and p-value (e.g., sign(FC) \* log10(pvalue)), then the positive scores are associated with upregulated genes and negative scores are associated with downregulated genes. Caution: some tools reverse this, so manually check a few to see which convention they are using. ES values range from -1 to 1. Normalized ES values will go a bit beyond these bounds. If you are seeing ES values \> 1, then I would suspect something is wrong.

Additional comment: You probably want to look at NES (Normalized ES) if that is provided by the tool you are using. The first two points above apply just the same.

```{r GSEA, eval=params$run.gsea}
# http://www.baderlab.org/ChangjiangXu/GSEA
# Create a gene rank based on the parameter chosen in the previous chunck
#####################
# RUN GESA ANALYSIS #
#####################

fgseaRes_GO <- gene_rank_list %>%
  map(., ~fgsea(pathways=GO_database, stats=.x)) %>%
  map(., ~as_tibble(.x)) %>%
  map(., ~arrange(.x, pval))

#fgseaRes_KEGG <- NULL
#fgseaRes_GO <- NULL
fgseaRes_KEGG <- gene_rank_list %>%
  map(., ~fgsea(pathways=KEGG_database, stats=.x)) %>%
  map(., ~as_tibble(.x)) %>%
  map(., ~arrange(.x, pval))

fgseaRes_TFT <- gene_rank_list %>%
  map(., ~fgsea(pathways=TFT_database, stats=.x)) %>%
  map(., ~as_tibble(.x)) %>%
  map(., ~arrange(.x, pval))

fgseaRes <- append(fgseaRes_GO, fgseaRes_KEGG)

# Show in a nice table:
# fgseaResTidy <- fgseaRes$`8` %>% 
#   top_n(15, abs(NES)) %>% 
#   dplyr::select(-leadingEdge, -ES, -nMoreExtreme) %>% 
#   arrange(padj) #%>% 
#   #DT::datatable()
```

### save GESA object

```{r save-fgseaRes, eval=params$run.gsea}
saveRDS(fgseaRes, paste0(result_dir,"fgseaRes_tables.RDS"))
saveRDS(fgseaRes, paste0(result_dir,"fgseaRes_tables_updated_DB.RDS"))
#saveRDS(c(fgsea_GO, fgsea_KEGG), paste0(result_dir,"fgseaRes_objects.RDS"))
```

```{r load-GESA-results, eval=isFALSE(params$run.gsea)}
fgseaRes <- readRDS(paste0(result_dir,"fgseaRes_tables.RDS"))
fgseaRes <- readRDS(paste0(result_dir,"fgseaRes_tables_updated_DB.RDS"))
#fgseaRes <- fgseaRes %>% bind_rows(., .id = "clus") %>% filter(padj <= 0.05)
```

```{r TFT-enrichment, eval=FALSE}
gene_list_sig <- gene_rank_df %>% 
  map(., ~filter(.x, p_val < 0.01)) %>% 
  #map(., ~filter(.x, p_val_adj < 0.05)) %>% 
  map(., ~.x$gene)

sig_leadingedge <- function(df, sig_genes) {
  f <- df %>%
  unnest(leadingEdge) %>%
  #nest(data = c(y, z))
  mutate(sig_leadingEdge = .$leadingEdge) %>%
  mutate(sig_leadingEdge = ifelse(.$leadingEdge %in% sig_genes, .$leadingEdge, NA)) %>%
  summarize(leadingEdge = list(leadingEdge),
            p_val_0.01 = list(na.omit(sig_leadingEdge)), .by = colnames(.)[1:7])
  return(f)
}
fgseaRes_TFT_ <- map2(fgseaRes_TFT,gene_list_sig, ~sig_leadingedge(.x, .y)) %>%
  map(., ~filter(.x, padj < 0.05)) %>%
  write.xlsx(., paste0(result_dir,"TFT_enrichment.xlsx"))
```

```{r Leading-edge-analysis}
# Calculate leading edge analysis from a fgesa results table
gseaScores <- getFromNamespace("gseaScores", "DOSE")
# tmp_res <- fgseaRes$Basal_1
# geneSets <- GO_database
# geneList <- gene_rank_list$Basal

# NB! this function assumes that the genes rank is ordered by increasing values (pos logFC to neg logFC)
# this affects the order of the core genes, but not the 
leading_edge <- function(res, geneSets, geneList){
  
    # Observed info (gseaScore):
    observed_info <- lapply(geneSets[res$pathway], function(gs)
        gseaScores(geneSet=gs,
                   geneList=geneList,
                   exponent=1)
        )
    
    observed_info <<- observed_info
    # Leading edge analysis:
    core_enrichment <- lapply(observed_info, function(x) {
        runningES <- x$runningES
        runningES <- runningES[runningES$position == 1,]
        ES <- x$ES
        if (ES >= 0) {
            i <- which.max(runningES$runningScore)
            leading_gene <- runningES$gene[1:i]
        } else {
            i <- which.min(runningES$runningScore)
            leading_gene <- runningES$gene[-c(1:i)]
        }
        return(leading_gene)
    })

    rank <- sapply(observed_info, function(x) {
        runningES <- x$runningES
        ES <- x$ES
        if (ES >= 0) {
            rr <- which.max(runningES$runningScore)
        } else {
            i <- which.min(runningES$runningScore)
            rr <- nrow(runningES) - i + 1
        }
        return(rr)
    })


    tags <- sapply(observed_info, function(x) {
        runningES <- x$runningES
        runningES <- runningES[runningES$position == 1,]
        ES <- x$ES
        if (ES >= 0) {
            i <- which.max(runningES$runningScore)
            res <- i/nrow(runningES)
        } else {
            i <- which.min(runningES$runningScore)
            res <- (nrow(runningES) - i + 1)/nrow(runningES)
        }
        return(res)
    })

    ll <- sapply(observed_info, function(x) {
        runningES <- x$runningES
        ES <- x$ES
        if (ES >= 0) { # if true assumes up regulation
            i <- which.max(runningES$runningScore)
            res <- i/nrow(runningES)
        } else { # assumes down regulation
            i <- which.min(runningES$runningScore)
            res <- (nrow(runningES) - i + 1)/nrow(runningES)
        }
        return(res)
    })

    
    N <- length(geneList)
    signal <- tags * (1-ll) * (N / (N - res$size))

    tags <- paste0(round(tags * 100), "%")
    ll <- paste0(round(ll * 100), "%")
    signal <- paste0(round(signal * 100), "%")
    LE_analysis <- paste0('tags=', tags, ", list=", ll, ", signal=", signal)
    
    res$rank_at_max <- rank
    res$leading_edge <- LE_analysis
    res$core_enrichment <- sapply(core_enrichment, paste0, collapse=',')
    return(res)

}
db_ids <- list("GO" = set_names(GO_database$exactSource, GO_database$pathway),
               "KEGG" = set_names(KEGG_database$exactSource, KEGG_database$pathway))

db <- c(rep("GO", length(fgseaRes)/2),rep("KEGG", length(fgseaRes)/2))
fgseaRes_df <-  tibble(Clusters=names(fgseaRes),
                      db = db, fgseaRes = fgseaRes) %>%
  mutate(fgseaRes = pmap(., ~mutate(..3, id = db_ids[[..2]][.data[["pathway"]] ], .before="pathway" ) )) %>% # 
  mutate(fgseaRes = pmap(., ~filter(..3, padj < 0.05) )) %>%
  filter(unlist(map(.$fgseaRes, ~nrow(.x) > 0)))

fgseaRes_LE <- fgseaRes_df %>% 
  mutate(fgseaRes = pmap(., ~leading_edge(..3, get(paste0(..2,"_database"))$db, gene_rank_list[[..1]]) )) %>%
  mutate(fgseaRes = set_names(.$fgseaRes, paste0(.data[["Clusters"]]) )) %>%
  {. ->> fgseaRes_filt} %>%
  group_by(db) %>%
  summarise(fgseaRes = list(fgseaRes), .groups = "drop")

# save object:
saveRDS(fgseaRes_filt, paste0(result_dir,"fgseaRes_filt_tables.RDS")) 
# fgseaRes_LE <- readRDS(paste0(result_dir,"fgseaRes_filt_tables.RDS"))
```

`Rank at max`The position in the ranked list at which the maximum enrichment score occurred. The more interesting gene sets achieve the maximum enrichment score near the top or bottom of the ranked list; that is, the rank at max is either very small or very large. 
`Tags` to indicate the percentage of genes contributing to the enrichment score (leadingEdge/size*100), 
`List` to indicate where in the list the enrichment score is attained, it reports the percentage of genes before (for positive ES) or after (for negative ES) the peak in the running enrichment score. 
`Signal` for enrichment signal strength.

I think the dependency on ES being negative or positive could be problematic in certain instances where there is an equal balance of negative and positive genes

```{r GOslim}
library(GSEABase)
library(GO.db)
path_slim <- "/Users/vilkal/work/Brolidens_work/Projects/Spatial_DMPA/resources/goslim_agr.obo"
slim <- getOBOCollection(path_slim)

mappedIds <- function(df, collection){
  # this function identifies all children for a set of supplied goIDs
    map <- as.list(GO.db::GOBPOFFSPRING[rownames(df)])
    mapped <- lapply(map, intersect, ids(collection))
    #df[["go_ids"]] <- vapply(unname(mapped), paste, collapse = ",", character(1L))
    df[["go_ids"]] <- mapped
    df[["go_terms"]] <- map(unname(mapped), ~paste(go[.x]), collapse = ";") # paste(go[unlist(mapped)], collapse = ";")
    df
  }

goterms <- tibble("Term"=Term(GOTERM), "id"=names(Term(GOTERM))) %>%
  mutate(t = paste0("GOBP_", toupper(.$Term)) ) %>%
  mutate(t = gsub(x = .$t, " |-|, |/","_" ))
go <- set_names(goterms$Term, goterms$id)

slim_df <- fgseaRes_df %>%
  filter(db == "GO") %>%
  mutate(morf = ifelse(grepl("\\d", .$Clusters), "SubMuc", "epi")) %>%
  filter(!(grepl(submuc_remove, .$Clusters))) %>%
  #mutate(go_ids = pmap(., ~left_join(..3, goterms, by=c("pathway"="t"))[["id"]] )) %>%
  mutate(go_ids = pmap(., ~..3[["id"]])) %>%
  select(morf, go_ids) %>%
  
  # GO slim data:
  summarise(go_ids = list(unique(unlist(.$go_ids[cur_group_rows()]))), .by="morf") %>%
  mutate(myCollection = pmap(., ~GOCollection(na.omit(..2), ontology="BP") )) %>%
  mutate(slimdf = pmap(., ~goSlim(..3, slim, "BP") )) %>%
  mutate(slim = pmap(., ~as_tibble(mappedIds(..4, ..3), rownames = "SlimID") )) %>%
  
  mutate(slim = setNames(.[["slim"]], .$morf))

list("Epithelium"=slim_df$slim[[1]], "Submucosa"=slim_df$slim[[2]]) %>%
  {. ->> slim_lst} %>%
  write.xlsx(., paste0(result_dir,"GOslim_summary_New.xlsx"))
```

```{r save-supplementary-table}
############################
# SAVE SUPPLEMENTARY TABLE #
############################
append(slim_lst, fgseaRes_LE$fgseaRes[[1]]) %>%
write.xlsx(., keepNA=TRUE, na.string="NA", overwrite=TRUE,
                             file=paste0(result_dir,"Supplemental Table 5.xlsx"))
```

```{r piechart-GOslim}
pal <- c(RColorBrewer::brewer.pal(10,"Paired"),
         RColorBrewer::brewer.pal(8,"Set2"),
         RColorBrewer::brewer.pal(8,"Dark2") )
         #RColorBrewer::brewer.pal(9,"Pastel1"),
         #RColorBrewer::brewer.pal(8,"Pastel2")

df <- slim_df$slim[[1]] %>%
  filter(!(Percent == 0)) %>%
  arrange(desc(Percent)) %>%
  mutate(Term = factor(.$Term, levels = .$Term)) %>%
  mutate(ystart = c(0, cumsum(Percent)[1:nrow(.)-1])) %>%
  mutate(yend = lead(ystart, default = 100)) 

ggplot(df) + 
  # ajust the width of the circle by changing max and min x values
  # to get a rageular pice chart set xmin=0
  geom_rect(aes(fill=Term, ymax=yend, ymin=ystart, xmax=4, xmin=3)) +
  # geom_rect(aes(fill=SlimID, ymax=yend, ymin=ystart, xmax=3, xmin=0)) +
  xlim(c(0, 4)) + scale_fill_manual(values = pal) +
  theme(aspect.ratio=1) + theme_void() +
  coord_polar(theta="y")  
```

```{r}
self = NULL
upper = TRUE
method = "rsquared"
strategy = "atLeastOne"
min_measures = 3L
post_norm = TRUE
parallel = FALSE

m <- parallel::mclapply(seq_len(nrow(readouts)), function(is1) {
    ret <- sapply(1:is1, function(is2) {
      dat <- readouts[c(is1, is2), , drop = FALSE]
      if (strategy == "atLeastOne")
        dat <- dat[, dat[1, ] != 0 | dat[2, ] != 0, drop = FALSE]
      if (ncol(dat) < min_measures) {
        return(NA)
      }
 if (method == "rsquared") {
        fit <- stats::lm(y ~ 0 + x,
                         data = data.frame(x = dat[1, ], y = dat[2, ]))
        return(ifelse(is.na(fit$coefficients[["x"]]),
                      NA,
                      suppressWarnings(summary(fit)$r.squared)))
      } else {
        return(stats::dist(x = dat / apply(dat, MARGIN = 1, max),
                           method = method))
      }
    })
    return(c(ret, rep(NA, nrow(readouts) - length(ret))))
  }, mc.cores = ifelse(parallel,
                       getOption("mc.cores", parallel::detectCores()),
                       1))
m <- do.call("rbind", m)
  if (upper) {
    m[upper.tri(m, diag = FALSE)] <- t(m)[upper.tri(m, diag = FALSE)]
  }
  dimnames(m) <- list(rownames(readouts), rownames(readouts))

  if (length(stats::na.omit(diag(m))) != 0 &&
      unique(stats::na.omit(diag(m))) == 0) {
    m <- 1 - m
  }

  if (post_norm && !all(is.na(m))) {
    m <- m - min(m, na.rm = TRUE)
    m <- m / max(m, na.rm = TRUE)
  }

  if (!is.null(self)) {
    diag(m) <- self
  }
```


```{r fgseaRes-filtered}
sig_epi_GO <- fgseaRes_filt$fgseaRes[1:4] %>% bind_rows(., .id = "clus") %>% filter(!(grepl("\\d", .$clus))) %>% filter(padj<=0.05) #%>% .$pathway %>% unique()
sig_sub_GO <- fgseaRes_filt$fgseaRes[5:8] %>% bind_rows(., .id = "clus") %>% filter(grepl("\\d", .$clus)) %>% filter(padj<=0.05) #%>% .$pathway %>% unique()
#sig_sub_GO <- fgseaRes[5:8] %>% bind_rows(., .id = "clus") %>% filter(grepl("\\d", .$clus)) %>% filter(padj<=0.05)
```

```{r Enrichment-graph-epi}
# Modified code by YuLab from enrichplot package:
# https://github.com/YuLab-SMU/enrichplot/blob/devel/R/emapplot_utilities.R

overlap_ratio <- function(x, y) {
    x <- unlist(x)
    y <- unlist(y)
    # gene overlap between nodes are used as weights:
    length(intersect(x, y))/length(unique(c(x,y))) }

##' Get the similarity matrix
##'
##' @param y A data.frame of enrichment result
##' @param geneSets A list, the names of geneSets are term ids,
##' and every object is a vertor of genes.
##' @param method Method of calculating the similarity between nodes,
##' one of "Resnik", "Lin", "Rel", "Jiang" , "Wang"  and
##' "JC" (Jaccard similarity coefficient) methods
##' @param semData GOSemSimDATA object
##' @noRd
d <- GOSemSim::godata('org.Hs.eg.db', ont="BP")

library(ggraph)
library(tidygraph)
library(igraph)
library(ggnewscale)

# gene overlap between nodes are used as weights:
get_similarity_matrix <- function(y, geneSets, method="JC", semData = NULL) {
    id <- y$pathway
    geneSets <- set_names(y$leadingEdge, id)
    
    n <- nrow(y)
    y_id <- unlist(strsplit(y$pathway, "_"))[1]
    ## Choose the method to calculate the similarity
    if (method == "JC") {
        w <- matrix(NA, nrow=n, ncol=n)
        colnames(w) <- rownames(w) <- y$pathway
        for (i in seq_len(n-1)) {
            for (j in (i+1):n) {
                w[i,j] <- overlap_ratio(geneSets[id[i]], geneSets[id[j]])
            }
        }
        return(w)
    }

    if (y_id == "GO" | y_id == "GOBP") {
        if(is.null(semData)) {
            stop("The semData parameter is missing,
                and it can be obtained through godata function in GOSemSim package.")
        }
        w <- GOSemSim::mgoSim(id, id, semData=semData, measure="Wang",
                              combine=NULL)
    }

    if (y_id == "DOID") w <- DOSE::doSim(id, id, measure="Wang")
    rownames(y) <- y$pathway
    rownames(w) <- colnames(w) <- y[colnames(w), "pathways"]
    return(w)
}
build_emap_graph <- function(sim_m, fgesa_df, method = "JC", cex_line = 1, min_edge = 0.2){
  # Use similarity as the weight(length) of an edge
  wd <- pivot_longer(cols = -1, as_tibble(sim_m, rownames = "from"), names_to = "to", values_to = "weight")
      wd <- wd[wd[,1] != wd[,2],]
      # remove NA
      wd <- wd[!is.na(wd[,3]),]
      
      # Create network tidy:
      nodes <- fgesa_df %>% dplyr::select(pathway)
      edges <- wd %>% mutate(width = sqrt(.$weight * 5)* cex_line)
      
      graph <- list()
      g <- tbl_graph(nodes, edges, directed = FALSE)
      # filter edges
      g <- g %>% activate(edges) %>% filter(weight > min_edge) %>% activate(nodes)
      graph$tidy <- g 
      
      # Create network igraph:
      # g <- graph.data.frame(wd[, -3], directed=FALSE)
      # E(g)$width <- sqrt(wd[, 3] * 5) * cex_line
      # # Use similarity as the weight(length) of an edge
      # E(g)$weight <- wd[, 3]
      # # filter edges
      # g <- delete.edges(g, E(g)[wd[, 3] > min_edge])
      # graph$igraph <- g
  
  return(graph)
}

dge <- DEGs_table %>% 
  filter(grepl("[^\\d]", .$layers)) %>% 
  filter(p_val<=0.01) %>%
  #filter(pct.1 > .4 & p_val < 0.01)  
  split(., ~layers) %>%  map(., ~.x$gene)
# temp_ <- fgseaRes$Basal_1 %>% filter(padj<=0.05)
# m <- get_similarity_matrix(temp_, geneSets=GO_database, semData=d) 
# graph <- build_emap_graph(sim_m=m, fgesa_df=temp_, cex_line=1, min_edge=0)

ord1 <- c("Superficial","Upper IM","Lower IM","Basal","8","3","4","0","1","2","10")
ord2 <- c("Sup_1", "Sup_2", "Basal_2", "Basal_2","8","3","0","4","1","2","10")
l <- set_names(ord1, ord2)

GO_comb_epi <- sig_epi_GO %>% 
  #mutate(., clus = factor(l[as.character(.$clus)], levels = ord1)) %>%
  add_count(pathway) %>% 
  rename(GOid="id") %>%
  left_join( select(goterms, Term, t), by=c("pathway"="t")) %>%
  #mutate(Term = str_replace_all(tolower(.$pathway), "_", " ")) %>%
  #mutate(Term = str_replace(.$Term, "^gobp ", "")) %>%
  # filter leading edge by parameters set above:
  #mutate("p<0.01" = pmap(., ~intersect(..10, dge[[..1]]))) %>%
  # combine same terms from different clusters:
  mutate("leadingEdge_comb" = list(unique(unlist(.$leadingEdge[cur_group_rows()]))), .by="pathway") %>%
  mutate(pathway = paste0(.$clus, ":", .$GOid)) %>%
  mutate("Sig. in" = paste0(.$clus[cur_group_rows()], collapse = "|"), .by="GOid") %>%
  #filter((is.na(.$id))) %>%
  filter(!(is.na(.$Term))) %>%
  # removes the idential terms:
  slice_max(n=1, order_by = tibble(abs(NES), size), by="Term") %>%
  ungroup()
  
#### get similarity matrix and create graph ####
# weight is the percentage overlap between the two terms
m <- get_similarity_matrix(GO_comb_epi, geneSets=GO_database, semData=d) 
set.seed(123); graph <- build_emap_graph(sim_m=m, fgesa_df=GO_comb_epi, cex_line=1, min_edge=0.1)
# G <- as_tbl_graph(graph$igraph)

#### find number of edges between nodes: ####
m %>% as_tibble(., rownames="from")
summary <- graph$tidy %>% activate(edges) %>% 
  as_tibble() %>%
  summarise(l = sum(weight), # n is number of shared genes with other terms, l is the sum of weights
            n_genes = sum(weight > 0), .by = "from" )  %>% 
  arrange(n_genes)
s <- set_names(summary$n_genes, as.character(summary$from))

# graph$tidy %>% activate(edges) %>% as_tibble() %>% filter(weight < 0)
# https://tidygraph.data-imaginist.com/reference/index.html

#### Add info to Graph ####
# https://bookdown.org/markhoff/social_network_analysis/centrality.html
set.seed(123);G <- graph$tidy %>% 
  mutate(gene_module = str_extract(as_tibble(.)$pathway, "[^:]+") ) %>%
  left_join(., select(GO_comb_epi, size, pathway, "Sig. in"), by="pathway") %>%
  mutate(pathway = str_extract(as_tibble(.)$pathway, "GO:\\d+") ) %>%
  mutate(degree = centrality_degree(),
         btwn = centrality_betweenness(),
         closness = centrality_closeness(),
         community = as.character(group_louvain())) %>%
  mutate(community = factor( as_tibble(.)$community, 
                             levels = as.character(1:max(as.integer(as_tibble(.)$community))) )) %>%
  left_join(goterms, by=c("pathway"="id")) %>%
  
  #filter(community == "1" | community == "2" | community == "3" )  %>% #  | community == "3" | community == "4" | community == "5"
  {. ->> G_nodes} %>%
  activate(edges) %>% 
  left_join(summary, by="from") %>%
  mutate(term_from = .N()$Term[from]) %>%
  mutate(term_to = .N()$Term[to]) %>%
  mutate(comm = .N()$community[from]) %>%
  {. ->> G_edges} %>%
  activate(nodes)

#### get table version of graph ###
G_nodes_e <- G_nodes %>% as_tibble() # %>% split(., ~community)
Reduce(intersect, as.list(GOBPANCESTOR[na.omit(G_nodes_$pathway)]))
  
G_edges %>%
  #filter(weight > .6) 
  filter(!(comm == "1" & weight > .2))

#### filter graph ####
# https://bookdown.org/markhoff/social_network_analysis/centrality.html
t <- c("phagocytosis, engulfment","membrane invagination", "positive regulation of guanylate cyclase activity", "multicellular organismal water homeostasis","humoral immune response", "leukocyte mediated immunity", "adaptive immune response", "adaptive immune response based on somatic recombination of immune receptors built from immunoglobulin superfamily domains", "positive regulation of B cell activation","retina homeostasis", "leukocyte mediated immunity")
set.seed(123);G_epi <- G %>% 
  #filter(!(grepl(paste(t,collapse="|"), Term))) %>%
  activate(edges) %>%
  #filter(grepl("|^1$|^2$|", comm) & weight < .2) %>%
  #filter(!(comm == "1" & weight > .8)) %>%
  filter(!(comm == "1" & weight < .3 )) %>%
  filter(!(comm == "3" & weight < .3 )) %>%
  filter(!(comm == "2" & weight < .3 )) %>%
  filter(!(comm == "4" & weight < .3 )) %>%
  #filter(weight > .3) %>%
  #filter(grepl("|^1$|", comm) & weight > .6) %>%
  arrange(desc(weight)) %>%
  #filter(n > 10) %>%
  # mutate(width = .["width"]*.1) %>%
  activate(nodes) %>%
  # re-calculate degree after filtering and remove nodes with no connections
  # before re-clustering
  mutate(degree = centrality_degree()) %>%
  filter(degree > 0) %>%
  mutate(com = as.character(group_louvain()))

G_nodes_epi <- G_epi %>% as_tibble() 

g_table_epi <- G_epi %>% as_tibble() %>%
  #mutate(col = pal[.$com]) %>%
  select(community, com, pathway, Term, degree) %>% unique() %>% arrange(community) %>%
  mutate(community = factor( .$community, levels = as.character(1:max(as.integer(.$community))) )) %>%
  mutate(count = n_distinct(Term), .by = c("com")) %>%
  filter(count > 3) %>%
  left_join(., select(GO_comb_epi, Term, ES), by="Term") %>%
  slice_max(n=2, order_by = tibble(degree, abs(ES)), by="com", with_ties = F) %>%
  slice_max(n=1, order_by = tibble(abs(ES)), by="com", with_ties = F) %>%
  dplyr::mutate(n = row_number(), .by="community") %>%
  #mutate(Term = str_replace(.$Term, "(.{10,}?)\\s", "\\1\n")) %>%
  arrange(community) %>%
  mutate(Cluster = paste0(.$community,"^",.$n), .after="community" ) %>%
  select(-com, -count) 
  

#### Plot graph ####
pal <- c(scales::hue_pal()(8),
             RColorBrewer::brewer.pal(9,"Set1"),
             RColorBrewer::brewer.pal(8,"Set2"),
             RColorBrewer::brewer.pal(8,"Accent"),
             RColorBrewer::brewer.pal(9,"Pastel1"),
             RColorBrewer::brewer.pal(8,"Pastel2"), c( "#364B9A", "#4A7BB7", "#6EA6CD","#98CAE1"), col )

pal <- set_names(pal[1:length(unique(G_nodes_$com))], sort(unique(G_nodes_$com)))
pal <- set_names(pal[1:length(unique(G_nodes_$community))], sort(unique(G_nodes_$community)))

c <- c(  "1",     "10",     "11",     "12",     "13",     "14",     "15",     "16",     "17",     "2",      "3",      "4",      "5",      "6",      "7",      "8",      "9")
col <- c("#FFD92F","#7CAE00","#E41A1C","#377EB8","#4DAF4A","#F781BF","#B3CDE3","#BEAED4","#BF5B17","#CCEBC5","#FBB4AE","#DECBE4","#984EA3","#F8766D","#FED9A6","#66C2A5","#00A9FF")
pal_epi <- set_names(col, c)

# 'graphopt', 'stress', 'kk', 'mds', 'lgl', 'backbone', 
set.seed(1);p <- G_epi %>%
  left_join(., select(g_table_epi, pathway, lab="Term", n), by="pathway") %>%
  
  ggraph(layout = 'backbone') + # 'graphopt'
  geom_edge_fan(width = .3, aes(colour=width), show.legend = FALSE) +
  scale_edge_colour_gradient(low="#DFDFDF", high = "#616161") + # colors=c("#DFDFDF" ,"#616161")
  new_scale_color() + theme_graph() +
  #geom_node_point(aes(color="red")) +
  geom_node_point(aes(color=community), size=2) + # community 
  #geom_node_point(aes(color=btwn), size=2) + 
  scale_colour_manual(values = pal_epi) +
  guides(colour = guide_legend(byrow = TRUE)) +
  #geom_node_text(aes(label = n, colour="white"), show.legend = F, nudge_y = .4) + #repel = TRUE, 
  geom_node_text(aes(label = n), show.legend = F,  nudge_x = .4) +
  theme(plot.margin = unit(c(-.1,0,-.2,-.2), "inches"),
        legend.title = element_blank(),
        legend.key.size = unit(0.008, "cm"),
        legend.spacing.y = unit(.1, 'cm'),
        legend.position = c(.96, .70),
        legend.justification = c("right", "top") ) 
  #facet_nodes(~gene_module)
  
# dev.new(width=5.5, height=5, noRStudioGD = TRUE)
ggsave(paste0(result_dir,"./Epi_enrichment_graph.tiff"), plot = p, width = 6, height = 5 )

knitr::kable(g) %>%
kableExtra::as_image()
```

```{r enrichment-table}
dge <- DEGs_table %>% 
  #filter(grepl("[^\\d]", .$layers)) %>% 
  #filter(p_val<=0.01) %>%
  filter(p_val_adj<=0.05) %>%
  #filter(pct.1 > .4 & p_val < 0.01)  
  split(., ~layers) %>%
  map(., ~.x$gene)

walk(., ~assign(x = "dge", value = .x$gene)) %>%
walk(., ~assign(x = "reg", value = .x$Regulation))

dge_epi <- dge[1:4] %>% unlist()
dge_sub <- dge[5:8] %>% unlist()

GO_degs <- GO_comb_epi %>% 
  mutate("p<0.05" = pmap(., ~intersect(..10, dge[[..1]]))) %>% 
  #mutate("p<0.05" = pmap(., ~intersect(..10, dge_epi))) %>% 
  left_join(., select(G_nodes_e, pathway, degree, community), by=c("GOid"="pathway")) %>%
  
  arrange(community) %>%
  mutate(row_id = 1:nrow(.)) %>%
  mutate(n_sg = map_int(.$`p<0.05`,~length(.x))) %>%
  select(Term, community, `p<0.05`) %>%
  unnest(cols = c("p<0.05")) %>%
  mutate(g = paste0(unique(.$`p<0.05`[cur_group_rows()]), collapse = ","), .by="community") %>%
  select(community, g) %>% unique()
  
d <- paste(unlist(GO_degs$g), collapse = ",") %>% str_split(., ",") %>% unlist() %>% unique(.) #%>% length()
setdiff(unique(unlist(dge_epi)), d)
  
GO_degs <- GO_comb_sub %>%
  mutate("p<0.05" = pmap(., ~intersect(..17, dge[[..1]]))) %>% 
  left_join(., select(G_nodes_s, pathway, degree, community), by=c("GOid"="pathway")) %>%
  arrange(community) %>%
  mutate(row_id = 1:nrow(.)) %>%
  mutate(n_sg = map_int(.$`p<0.05`,~length(.x))) %>%
  select(Term, community, `p<0.05`) %>%
  unnest(cols = c("p<0.05")) %>%
  mutate(g = paste0(unique(.$`p<0.05`[cur_group_rows()]), collapse = ","), .by="community") %>%
  select(community, g) %>% unique()

d <- paste(unlist(GO_degs$g), collapse = ",") %>% str_split(., ",") %>% unlist() %>% unique(.) #%>% length()
setdiff(unique(unlist(dge_sub)), d)

length(intersect( unique(G_nodes_s$pathway), unique(GO_comb_sub$id)))
```

```{r plot-GOslim-on-graph}
# there are GO terms missing from the GOslim list
length(unique(GO_comb_epi$GOid))
sum(slim_df[[5]][[1]]$Count)
setdiff(unique(GO_comb_epi$GOid), unlist(slim_df[[5]][[1]]$go_ids))
intersect(unique(GO_comb_epi$GOid), unlist(slim_df[[5]][[1]]$go_ids))

GOslim_l <- slim_df[[5]][[1]] %>%
  unnest(c("go_ids")) 

GOslim_l <- slim_df[[5]][[2]] %>%
  unnest(c("go_ids")) 

GOslim_l <- set_names(GOslim_l$Term, GOslim_l$go_ids)

pal <- c(RColorBrewer::brewer.pal(10,"Paired"),
         RColorBrewer::brewer.pal(8,"Set2"),
         RColorBrewer::brewer.pal(8,"Dark2") )
         #RColorBrewer::brewer.pal(9,"Pastel1"),
         #RColorBrewer::brewer.pal(8,"Pastel2")    

pal <- set_names(pal[1:17], df$epi$Term)
    
set.seed(1);p <- map(list(G_epi, G_sub), ~.x %>% #G_sub, G_epi
  mutate(GOslim = factor(GOslim_l[as_tibble(.)$pathway], levels=df$epi$Term)) %>%
  #left_join(., select(g_table_epi, pathway, lab="Term", n), by="pathway") %>%
  #left_join(., select(GOslim_l, pathway="go_ids", GOslim="Term"), by="pathway") %>%
  
  ggraph(layout = 'backbone') + # 'graphopt'
  geom_edge_fan(width = .3, aes(colour=width), show.legend = FALSE) +
  scale_edge_colour_gradient(low="#DFDFDF", high = "#616161") + # colors=c("#DFDFDF" ,"#616161")
  new_scale_color() + theme_graph() +
  #geom_node_point(aes(color="red")) +
  geom_node_point(aes(color=GOslim), size=2) + # community 
  #geom_node_point(aes(color=btwn), size=2) + 
  scale_colour_manual(values = pal) +
  guides(colour = guide_legend(byrow = TRUE)) +
  #geom_node_text(aes(label = n, colour="white"), show.legend = F, nudge_y = .4) + #repel = TRUE, 
  #geom_node_text(aes(label = n), show.legend = F,  nudge_x = .4) +
  theme(plot.margin = unit(c(-.1,0,-.2,-.2), "inches"),
        legend.title = element_blank(),
        legend.key.size = unit(0.008, "cm"),
        legend.spacing.y = unit(.1, 'cm'),
        #legend.position = c(.96, .70),
        #legend.justification = c("right", "top") 
        ) )
```


```{r Enrichment-graph-submuc}
dge <- DEGs_table %>% 
  filter(grepl("[\\d]", .$layers)) %>% 
  filter(p_val<=0.01) %>%
  #filter(pct.1 > .4 & p_val < 0.01)  
  split(., ~layers) %>%  map(., ~.x$gene)

# because i filtered away the terms (n=38) with no match in the GOTERM db, the result is different 
# when not removing these, much more messy plot
GO_comb_sub <- sig_sub_GO %>% 
  #mutate(., clus = factor(l[as.character(.$clus)], levels = ord1)) %>%
  add_count(pathway) %>% 
  #mutate(Term = str_replace_all(tolower(.$pathway), "_", " ")) %>%
  #mutate(Term = str_replace(.$Term, "^gobp ", "")) %>%
  rename(GOid = "id") %>%
  left_join( select(goterms, Term, t, id), by=c("pathway"="t")) %>%
  # filter leading edge by parameters set above:
  #mutate("p<0.01" = pmap(., ~intersect(..10, dge[[..1]]))) %>%
  # combine same terms from different clusters:
  mutate("leadingEdge_comb" = list(unique(unlist(.$leadingEdge[cur_group_rows()]))), .by="pathway") %>%
  mutate(pathway = paste0(.$clus, ":", .$id)) %>%
  mutate("Sig. in" = paste0(.$clus[cur_group_rows()], collapse = "|"), .by="Term") %>%
  #filter((is.na(.$id))) %>%
  filter(!(is.na(.$id))) %>%
  # removes the idential terms:
  slice_max(n=1, order_by = tibble(abs(NES), size), by="Term") %>%
  ungroup()
  
#### get similarity matrix and create graph ####
# weight is the percentage overlap between the two terms
m <- get_similarity_matrix(GO_comb_sub, geneSets=GO_database, semData=d) 
set.seed(123); graph <- build_emap_graph(sim_m=m, fgesa_df=GO_comb_sub, cex_line=1, min_edge=0.1)
# G <- as_tbl_graph(graph$igraph)

#### find number of edges between nodes: ####
m %>% as_tibble(., rownames="from")
summary <- graph$tidy %>% activate(edges) %>% 
  as_tibble() %>%
  summarise(l = sum(weight), # n is number of shared genes with other terms, l is the sum of weights
            n_genes = sum(weight > 0), .by = "from" )  %>% 
  arrange(n_genes)
s <- set_names(summary$n_genes, as.character(summary$from))

# graph$tidy %>% activate(edges) %>% as_tibble() %>% filter(weight < 0)
# https://tidygraph.data-imaginist.com/reference/index.html

#### Add info to Graph ####
# https://bookdown.org/markhoff/social_network_analysis/centrality.html
set.seed(123);G <- graph$tidy %>% 
  mutate(gene_module = str_extract(as_tibble(.)$pathway, "[^:]+") ) %>%
  left_join(., select(GO_comb_sub, size, pathway, "Sig. in"), by="pathway") %>%
  mutate(pathway = str_extract(as_tibble(.)$pathway, "GO:\\d+") ) %>%
  mutate(degree = centrality_degree(),
         btwn = centrality_betweenness(),
         closness = centrality_closeness(),
         community = as.character(group_louvain())) %>%
  mutate(community = factor( as_tibble(.)$community, 
                             levels = as.character(1:max(as.integer(as_tibble(.)$community))) )) %>%
  left_join(goterms, by=c("pathway"="id")) %>%
  mutate(GOslim = GOslim_l[as_tibble(.)$pathway]) %>%
  
  #filter(community == "1" | community == "2" | community == "3" )  %>% #  | community == "3" | community == "4" | community == "5"
  {. ->> G_nodes} %>%
  activate(edges) %>% 
  left_join(summary, by="from") %>%
  mutate(term_from = .N()$Term[from]) %>%
  mutate(term_to = .N()$Term[to]) %>%
  mutate(comm = .N()$community[from]) %>%
  {. ->> G_edges} %>%
  activate(nodes)

#### get table version of graph ###
G_nodes_s <- G_nodes %>% as_tibble() # %>% split(., ~community)
G_edges <- G_edges %>% as_tibble() 
Reduce(intersect, as.list(GOBPANCESTOR[na.omit(G_nodes$pathway)]))
  
G_edges %>%
  #filter(weight > .6) 
  filter(!(comm == "1" & weight > .2))

#### filter graph ####
# https://bookdown.org/markhoff/social_network_analysis/centrality.html
t <- c("phagocytosis, engulfment","membrane invagination", "positive regulation of guanylate cyclase activity", "multicellular organismal water homeostasis","humoral immune response", "leukocyte mediated immunity", "adaptive immune response", "adaptive immune response based on somatic recombination of immune receptors built from immunoglobulin superfamily domains", "positive regulation of B cell activation","retina homeostasis", "leukocyte mediated immunity")
set.seed(123);G_sub <- G %>% 
  #filter(!(grepl(paste(t,collapse="|"), Term))) %>%
  activate(edges) %>%
  #filter(grepl("|^1$|^2$|", comm) & weight < .2) %>%
  #filter(!(comm == "1" & weight > .8)) %>%
  filter(!(comm == "1" & weight < .3 )) %>%
  filter(!(comm == "3" & weight < .3 )) %>%
  filter(!(comm == "2" & weight < .3 )) %>%
  filter(!(comm == "4" & weight < .3 )) %>%
  filter(!(comm == "5" & weight < .3 )) %>%
  #filter(!(comm == "6" & weight < .3 )) %>%
  filter(!(comm == "7" & weight < .3 )) %>%
  #filter(weight > .3) %>%
  #filter(grepl("|^1$|", comm) & weight > .6) %>%
  arrange(desc(weight)) %>%
  #filter(n > 10) %>%
  # mutate(width = .["width"]*.1) %>%
  activate(nodes) %>%
  # re-calculate degree after filtering and remove nodes with no connections
  # before re-clustering
  mutate(degree = centrality_degree()) %>%
  filter(degree > 0) %>%
  mutate(com = as.character(group_louvain()))

G_nodes_sub <- G_sub %>% as_tibble() 

# select terms to label in graph and diplay in table:
g_table_sub <- G_sub %>% as_tibble() %>%
  mutate(col = pal[.$com]) %>%
  select(community, com, pathway, Term, degree) %>% unique() %>% arrange(community) %>%
  mutate(count = n_distinct(Term), .by = c("com")) %>%
  #filter(count > 4) %>%
  left_join(., select(GO_comb_sub, id, ES), by=c("pathway"="id")) %>%
  # mutate(ES = ) %>%
  slice_max(n=2, order_by = tibble(degree, abs(ES)), by="com", with_ties = F) %>%
  slice_max(n=1, order_by = tibble(abs(ES)), by="com", with_ties = F) %>%
  dplyr::mutate(n = row_number(), .by="community") %>%
  mutate(community = factor( .$community, levels = as.character(1:17)) ) %>%
  #mutate(Term = str_replace(.$Term, "(.{10,}?)\\s", "\\1\n")) %>%
  arrange(community) %>%
  mutate(Cluster = paste0(.$community,"^",.$n), .after="community" ) 

#### Plot graph ####
library(ggnewscale)
pal <- c(scales::hue_pal()(8),
             RColorBrewer::brewer.pal(9,"Set1"),
             RColorBrewer::brewer.pal(8,"Set2"),
             RColorBrewer::brewer.pal(8,"Accent"),
             RColorBrewer::brewer.pal(9,"Pastel1"),
             RColorBrewer::brewer.pal(8,"Pastel2"), c( "#364B9A", "#4A7BB7", "#6EA6CD","#98CAE1") )

pal <- set_names(pal[1:length(unique(G_nodes_$com))], sort(unique(G_nodes_$com)))
pal <- set_names(pal[1:length(unique(G_nodes_$community))], sort(unique(G_nodes_$community)))
c <- c(  "1",     "10",     "11",     "12",     "13",     "14",     "15",     "16",     "17",     "2",      "3",      "4",      "5",      "6",      "7",      "8",      "9",
         "18",    "19",     "20",     "21",     "22",     "23" )
col <- c("#FFD92F","#7CAE00","#E41A1C","#377EB8","#4DAF4A","#F781BF","#B3CDE3","#BEAED4","#BF5B17","#CCEBC5","#FBB4AE","#DECBE4","#984EA3","#F8766D","#FED9A6","#66C2A5","#00A9FF",  "#FC8D62","#8DA0CB","#364B9A","#A6D854","#FFF2AE","#E5C494")
pal_sub <- set_names(col, c)

# 'graphopt', 'stress', 'kk', 'mds', 'lgl', 'backbone', 
set.seed(1);p <- G_sub %>%
  left_join(., select(g_table_sub, pathway, lab="Term", n), by="pathway") %>%
  #filter(!is.na(n)) %>% as_tibble() -> l
  
  ggraph(layout = 'backbone') + # 'graphopt'
  geom_edge_fan(width = .3, aes(colour=width), show.legend = FALSE) +
  scale_edge_colour_gradient(low="#DFDFDF", high = "#616161") + # colors=c("#DFDFDF" ,"#616161")
  new_scale_color() + theme_graph() +
  #geom_node_point(aes(color="red")) +
  geom_node_point(aes(color=community), size=2) + # community 
  #geom_node_point(aes(color=btwn), size=2) + 
  scale_colour_manual(values = pal_sub) +
  guides(colour = guide_legend(byrow = TRUE)) +
  #geom_node_text(aes(label = n, colour="white"), show.legend = F, nudge_y = .4) + #repel = TRUE, 
  geom_node_text(aes(label = n), show.legend = F,  nudge_x = .4) +
  theme(plot.margin = unit(c(-.1,0,-.2,-.2), "inches"),
        legend.title = element_blank(),
        legend.key.size = unit(0.008, "cm"),
        legend.spacing.y = unit(.1, 'cm'),
        legend.position = c(.96, .70),
        legend.justification = c("right", "top") ) 
  #facet_nodes(~gene_module)
  
# dev.new(width=5.5, height=5, noRStudioGD = TRUE)
ggsave(paste0(result_dir,"./Sub_enrichment_graph.tiff"), plot = p, width = 6, height = 5 )

base_size <- 8
ggtab <- ggtexttable(g[,-1], rows = NULL, 
            theme = # ttheme("light"))
            ttheme(base_style = "light",
                  base_colour = "#616161",
                  padding = unit(c(2, 2), "mm"),
                  #core = list(fg_params = list(parse=TRUE)),
                  colnames.style = colnames_style(size = base_size+2, fill = "white", color = "#616161"),
                  rownames.style = rownames_style(size = base_size+1),
                  tbody.style = tbody_style(color = "#616161", size = base_size, fill = "white", parse = T,
                                            hjust = as.vector(matrix(c(.5, 0, .5, .5, .5), ncol = 5, nrow = nrow(g), byrow = TRUE)),
                                            x = as.vector(matrix(c(0.5, .1, .5,.5, .5), ncol = 5, nrow = nrow(g), byrow = TRUE)) 
                                            )
                  )) 

# Coloring the table conditionnally using `ggpubr::table_cell_bg()`
for(i in 1:nrow(g)){ # nrow(g)
  #print(i)
  col <- g$community[i]
  #print(col)
  ggtab <- table_cell_bg(ggtab, 
                         row = i+1, column = 1, 
                         fill = pal_epi[as.character(col)], color = pal_epi[as.character(col)] )
  # ggtab <- table_cell_bg(ggtab, i+1, column = 4, linewidth = 1,
  #                        color = pal_epi[as.character(col)])
  print(ggtab)
}
ggsave(paste0(result_dir,"./Sub_enrichment_graph.tiff"), plot = ggtab, width = 6, height = 5 )
```

```{r enrichment_table}
# Coloring the table conditionnally using `ggpubr::table_cell_bg()`
tabel_col.fun<- function(ggtab, g, pal){
  for(i in 1:nrow(g)){
    #print(i)
    col <- g$community[i]
    #print(col)
    ggtab <- table_cell_bg(ggtab, 
                           row = i+1, column = 1, 
                           fill = pal[as.character(col)], color = pal[as.character(col)] )
    # ggtab <- table_cell_bg(ggtab, i+1, column = 4, linewidth = 1,
    #                        color = pal_epi[as.character(col)])
    print(ggtab)
  }}

base_size <- 8
g_table <- list("epi"=g_table_epi, "SubMuc"=g_table_sub)
pal_list <- list("epi"=pal_epi, "SubMuc"=pal_sub)
options(scipen=999)

ggtab <- imap(g_table, ~ .x[,-1] %>%
  select(-com, -count, -n) %>%
  mutate(ES = format(.$ES, digits = 2 ,scientific = FALSE) ) %>%
  #mutate(ES = factor(.$ES) ) %>%
  ggtexttable(., rows = NULL, 
            theme = # ttheme("light"))
            ttheme(base_style = "light",
                  base_colour = "#616161",
                  padding = unit(c(2, 2), "mm"),
                  #core = list(fg_params = list(parse=TRUE)),
                  colnames.style = colnames_style(size = base_size+2, fill = "white", color = "#616161"),
                  rownames.style = rownames_style(size = base_size+1),
                  tbody.style = 
                    tbody_style(
                      color = "#616161", size = base_size, fill = "transparent", #parse = T,
                      hjust = as.vector(matrix(c(.5, 0, .5, .5, 1), ncol = 5, nrow = nrow(.), byrow = TRUE)),
                      x = as.vector(matrix(c(0.5, .1, .5,.5, .9), ncol = 5, nrow = nrow(.), byrow = TRUE)) 
                  ) ))  %>%
  tabel_col.fun(., g_table[[.y]], pal_list[[.y]]) )

ggtab[[1]]
ggtab[[2]]

ggsave(paste0(result_dir,"./Sub_enrichment_graph.tiff"), plot = ggtab, width = 6, height = 5 )
```

```{r graph-per-layer}
m <- set_names(c("#E41A1C","#FF7F00", "#C77CFF","#984EA3"), c("Sup", "Upper", "Lower", "Basal"))

set.seed(1);p <- imap(m, 
  ~mutate(G_epi, col = factor(c(.x, "gray"))[ifelse(grepl(.y, G_nodes_epi$`Sig. in`), 1, 2)]) ) %>%
  
  imap(., ~ggraph(.x, layout = 'backbone') + # 'graphopt'
  geom_edge_fan(width = .3, aes(colour=width), show.legend = FALSE) +
  scale_edge_colour_gradient(low="#DFDFDF", high = "#616161") + # colors=c("#DFDFDF" ,"#616161")
  new_scale_color() +
  geom_node_point(aes(color=col), size=2) + # community `Sig. in`
  scale_colour_identity() +
  theme_graph() + theme(plot.margin = unit(c(0,0,0,0), "inches")) ) 
  #facet_nodes(~gene_module)
wrap_plots(p, ncol = 1)


m <- set_names(c("#00BFC4","#00A9FF","#377EB8","#CD9600"), c("8", "3","4", "0"))

set.seed(1);p <- imap(m, 
  ~mutate(G_sub, col = factor(c(.x, "gray"))[ifelse(grepl(.y, G_nodes_sub$`Sig. in`), 1, 2)]) ) %>%
  
  imap(., ~ggraph(.x, layout = 'backbone') + # 'graphopt'
  geom_edge_fan(width = .3, aes(colour=width), show.legend = FALSE) +
  scale_edge_colour_gradient(low="#DFDFDF", high = "#616161") + # colors=c("#DFDFDF" ,"#616161")
  new_scale_color() +
  geom_node_point(aes(color=col), size=2) + # community `Sig. in`
  scale_colour_identity() +
  theme_graph() + theme(plot.margin = unit(c(0,0,0,0), "inches")) ) 
  #facet_nodes(~gene_module)

# dev.new(width=5, height=15, noRStudioGD = TRUE)
p <- wrap_plots(p, ncol = 1)
ggsave(filename = "./Figures/07/enrich_plot_layers_sub.pdf", plot = p, width =5 , height =15 )
```

```{r piechart-GOslim}
pal2 <- c(RColorBrewer::brewer.pal(10,"Paired"),
         RColorBrewer::brewer.pal(8,"Set2"),
         RColorBrewer::brewer.pal(8,"Dark2") )
         #RColorBrewer::brewer.pal(9,"Pastel1"),
         #RColorBrewer::brewer.pal(8,"Pastel2")
  
G_nodes <- list("epi"=G_nodes_e, "SubMuc"=G_nodes_s)
pal_list <- list("epi"=pal_epi, "SubMuc"=pal_sub)

df <- imap(slim_df$slim, ~ .x %>% # slim_df$slim[[2]] %>%
          filter(!(Percent == 0)) %>%
          arrange(desc(Percent)) %>%
          mutate(Term = factor(.$Term, levels = .$Term)) %>%
          mutate(ystart = c(0, cumsum(Percent)[1:nrow(.)-1])) %>%
          mutate(yend = lead(ystart, default = 100)) %>% 
          {. ->> temp}  %>%
          unnest(go_terms) %>%
          left_join(., select(G_nodes[["SubMuc"]], community, go_terms="Term"), by=c("go_terms")) %>%
          #left_join(., select(G_nodes[[.y]], community, go_terms="Term"), by=c("go_terms")) %>%
          summarise(count = n_distinct(go_terms), .by = c("Term", "Count", "Percent","community", "ystart", "yend")) %>%
          #summarise(count = n_distinct(go_ids), .by = c("Term", "Count", "Percent","community", "ystart", "yend")) %>%
          mutate(Percent = count/sum(temp$Count)*100) %>%
          mutate(ystart2 = c(0, cumsum(Percent)[1:nrow(.)-1]/sum(Percent))*100) %>%
          mutate(yend2 = lead(ystart2, default = 100))  %>%
          mutate(community = ifelse(as.integer(.$community) > length(pal_list[[.y]]), NA, as.character(.$community))) %>%
          mutate(community = factor( .$community, levels = as.character(1:length(pal_list[[.y]]))) ) )

df$SubMuc %>%
pie_plots <- map2(df, pal_list,
                 ~ggplot(.x) + 
                # ajust the width of the circle by changing max and min x values
                # to get a rageular pice chart set xmin=0
                geom_rect(aes(fill=Term, ymax=yend, ymin=ystart, xmax=2.7, xmin=1)) +
                scale_fill_manual(values = pal2) + new_scale_fill() +
                geom_rect(aes(fill=community, ymax=yend2, ymin=ystart2, xmax=3.3, xmin=2.7)) +
                scale_fill_manual(values = .y, na.value = "gray") +
                xlim(c(0, 4)) + 
                theme(aspect.ratio=1) + theme_void() +
                coord_polar(theta="y")  )
pie_plots[[1]]
pie_plots[[2]]

ggsave(filename = "./Figures/07/GOslim_pichart_epi.pdf", plot = pie_plots[[1]], width =10 , height =10 )
ggsave(filename = "./Figures/07/GOslim_pichart_submuc.pdf", plot = pie_plots[[2]], width =10 , height =10 )
```

```{r Enrichment-gene-heatmap}
DEGs_ <- DEGs_table_epi %>% filter(Clusters == "Basal") %>% dplyr::select(., gene, avg_log2FC, p_val_adj)
l <- G %>% as_tibble() %>% filter(community == 3)

genes <- temp_ %>% filter(pathway %in% l$pathway) %>% 
  unnest(leadingEdge) %>%
  left_join(DEGs_, by=c("leadingEdge"="gene")) %>%
  add_count(leadingEdge) %>%
  arrange(desc(n)) %>%
  filter(p_val_adj < 0.05) %>%
  filter(abs(avg_log2FC) >= .1) %>%
  filter(leadingEdge %in% unique(.$leadingEdge)[1:10]) %>%
  .$leadingEdge %>% unique()

meta_df <- DATA %>% as_tibble() %>% dplyr::select(1:4, layers) 

# expression ctrl vs DMPA
df <- DATA %>% 
  FetchData(vars = genes, ) %>% 
  cbind(., "id"=meta_df$orig.ident,"groups"=meta_df$groups, "layers"=meta_df$layers) %>%
  filter(., grepl("_", .$layers)) %>% # select epithelium only
  as_tibble(., rownames = "cell_id") 

# select column grouping
df <- df %>%
  # group_by(groups, layers) %>% # summed by group + layer
  group_by(id, groups, layers) %>% # summed by id + group +layer
  summarise(across(-cell_id, ~sum(.)), .groups = "keep") %>%
  mutate(gr = pmap_chr(cur_group(), paste, sep = "_"), .before = "id") %>%
  #mutate(groups = paste0(.$groups,"_", .$layers)) %>%
  arrange(groups) %>%
  arrange(layers) %>%
  ungroup() %>%
  {. ->> meta_df} %>%
  dplyr::select(gr, any_of(genes)) %>%
  column_to_rownames(var = "gr") %>%
  as.matrix() %>% scale() %>% t()


# logFold value
df <- DEGs_table %>%
  filter(grepl(epi_clus, .$subgroup)) %>%
  filter(gene %in% genes) %>%
  dplyr::select(gene, layers, avg_log2FC) %>%
  unique() %>%
  arrange(layers) %>%
  # dplyr::group_by(Clusters) %>%
  # dplyr::summarise(n = dplyr::n(), .groups = "drop") %>%
  # dplyr::filter(n > 1L) 
  pivot_wider(., values_from = "avg_log2FC", names_from = "layers" ) %>%
  column_to_rownames(var = "gene") %>%
  as.matrix()


##############
# ANNOTATION #
##############
# not used
annot <- meta %>%
  filter(Trx =="yes") %>%
  select(ID, HIVstatus, Contraception, Tissue_gr, BV_Diagnosis_v3) %>%
  column_to_rownames(var = "ID") %>%
  arrange(ID)

anno <- annot %>%
  HeatmapAnnotation(df = ., 
                    col = list(
                      Contraception = c("DMPA"='#FB5273', "none"='#4FCEEF'),
                      Tissue_gr = c("T1"="#0072B2", "T2"="#009E73", "T3"="#D55E00", "T4"="#CC79A7", "T5"="#E69F00"),
                      BV_Diagnosis_v3 = c("BV"="tomato", "Interm"="orange","Normal"="#d7d7d7"),
                      HIVstatus = c("neg"="#d7d7d7","pos"="tomato") 
                             ))
############
# PLOTTING #
############
col = c("#364B9A", "#4A7BB7", "#6EA6CD", "#98CAE1", "#C2E4EF", "white", "#FEDA8B", "#FDB366", "#F67E4B", "#DD3D2D", "#A50026")
library(ComplexHeatmap)
library(circlize)

# average expression:
H <- Heatmap(df,
             column_split = factor(meta_df$layers),
             col = colorRamp2(seq(min(df),max(df), length.out=10), colorRampPalette(c(col))(10)), 
             cluster_columns = T
             ) #colorRampPalette(c(col))(10)

# log Fold Change:
meta_df <- meta_df %>% filter(., grepl("_", .$layers)) 
H <- Heatmap(df,
             col = colorRamp2(seq(-.5,.5, length.out=10), colorRampPalette(c(col))(10)), 
             cluster_columns = F
             ) #colorRampPalette(c(col))(10)
```

```{r emapplot}
library(enrichplot)
leading_edge <- function(observed_info, res, geneList){
    core_enrichment <- lapply(observed_info, function(x) {
        runningES <- x$runningES
        runningES <- runningES[runningES$position == 1,]
        ES <- x$ES
        if (ES >= 0) {
            i <- which.max(runningES$runningScore)
            leading_gene <- runningES$gene[1:i]
        } else {
            i <- which.min(runningES$runningScore)
            leading_gene <- runningES$gene[-c(1:i)]
        }
        return(leading_gene)
    })

    rank <- sapply(observed_info, function(x) {
        runningES <- x$runningES
        ES <- x$ES
        if (ES >= 0) {
            rr <- which.max(runningES$runningScore)
        } else {
            i <- which.min(runningES$runningScore)
            rr <- nrow(runningES) - i + 1
        }
        return(rr)
    })


    tags <- sapply(observed_info, function(x) {
        runningES <- x$runningES
        runningES <- runningES[runningES$position == 1,]
        ES <- x$ES
        if (ES >= 0) {
            i <- which.max(runningES$runningScore)
            res <- i/nrow(runningES)
        } else {
            i <- which.min(runningES$runningScore)
            res <- (nrow(runningES) - i + 1)/nrow(runningES)
        }
        return(res)
    })

    ll <- sapply(observed_info, function(x) {
        runningES <- x$runningES
        ES <- x$ES
        if (ES >= 0) {
            i <- which.max(runningES$runningScore)
            res <- i/nrow(runningES)
        } else {
            i <- which.min(runningES$runningScore)
            res <- (nrow(runningES) - i + 1)/nrow(runningES)
        }
        return(res)
    })

    
    N <- length(geneList)
    signal <- tags * (1-ll) * (N / (N - res$setSize))

    tags <- paste0(round(tags * 100), "%")
    ll <- paste0(round(ll * 100), "%")
    signal <- paste0(round(signal * 100), "%")
    leading_edge <- paste0('tags=', tags, ", list=", ll, ", signal=", signal)
    
    res$rank <- rank
    res$rank_at_max <- rank
    res$leading_edge <- leading_edge
    res$core_enrichment <- sapply(core_enrichment, paste0, collapse='/')
    return(res)

}
calculate_qvalue <- function(pvals) {
    if (length(pvals) == 0)
        return(numeric(0))

    qobj <- tryCatch(qvalue(pvals, lambda=0.05, pi0.method="bootstrap"), error=function(e) NULL)
  
    # if (class(qobj) == "qvalue") {
    if (inherits(qobj, "qvalue")) {
        qvalues <- qobj$qvalues
    } else {
        qvalues <- NA
    }
    return(qvalues)
}
TERM2NAME <- function(term, USER_DATA) {
    PATHID2NAME <- get("PATHID2NAME", envir = USER_DATA)
    #if (is.null(PATHID2NAME) || is.na(PATHID2NAME)) {
    if (is.null(PATHID2NAME) || all(is.na(PATHID2NAME))) {
        return(as.character(term))
    }
    return(PATHID2NAME[term])
}
gseaScores <- getFromNamespace("gseaScores", "DOSE")

get_DOSE_obj <- function(tmp_res, geneSets=GO_database, geneList, pAdjustMethod="fdr", pvalueCutoff=1, verbose=T){
    p.adj <- p.adjust(tmp_res$pval, method=pAdjustMethod)
    qvalues <- calculate_qvalue(tmp_res$pval)

    Description <- tmp_res$pathway
    

    params <- list(pvalueCutoff = pvalueCutoff,
                   eps = NULL,
                   pAdjustMethod = pAdjustMethod,
                   exponent = NULL,
                   minGSSize = NULL,
                   maxGSSize = NULL
               )
    
    res <- data.frame(
        ID = as.character(tmp_res$pathway),
        Description = unname(Description),
        setSize = tmp_res$size,
        enrichmentScore = tmp_res$ES,
        NES = tmp_res$NES,
        pvalue = tmp_res$pval,
        p.adjust = p.adj,
        qvalue = qvalues,
        stringsAsFactors = FALSE
    )

    res <- res[!is.na(res$pvalue),]
    res <- res[ res$pvalue <= pvalueCutoff, ]
    res <- res[ res$p.adjust <= pvalueCutoff, ]
    idx <- order(res$p.adjust, -abs(res$NES), decreasing = FALSE)
    res <- res[idx, ]

    if (nrow(res) == 0) {
        message("no term enriched under specific pvalueCutoff...")
        return(
            new("gseaResult",
                result     = res,
                geneSets   = geneSets,
                geneList   = geneList,
                params     = params,
                readable   = FALSE
                )
        )
    }

    row.names(res) <- res$ID
    observed_info <- lapply(geneSets[res$ID], function(gs)
        gseaScores(geneSet=gs,
                   geneList=geneList,
                   exponent=1)
        )
    observed_info <<- observed_info
    res <<- res
    if (verbose)
        message("leading edge analysis...")

    res <- leading_edge(observed_info, res, geneList)

    # res$rank <- ledge$rank
    # res$leading_edge <- ledge$leading_edge
    # res$core_enrichment <- sapply(ledge$core_enrichment, paste0, collapse='/')

    if (verbose)
        message("done...")

    new("gseaResult",
        result     = res,
        geneSets   = geneSets,
        geneList   = geneList,
        params     = params,
        readable   = FALSE
        )
}

# gene_list_sig <- gene_rank_df$Basal_1 %>% filter(p_val_adj < 0.05) %>% .$gene
# tmp_res <- fgseaRes$Basal_1 %>% filter(padj<=0.05) 
  
gsea_obj <- get_DOSE_obj(tmp_res, geneList=gene_rank_list$Basal, geneSets=GO_database)
gsea_obj <- pairwise_termsim(gsea_obj)
p1 <- emapplot(gsea_obj, cex_label_category = .5)
emapplot(gsea_obj, group_category=T)
ggsave(filename = "./Figures/07/GSEA_graph_emapplot.pdf", plot = p1, width =10 , height =10 )


p3 <- cnetplot(gsea_obj, foldChange=gene_list_sig, geneSets=TFT_database, circular = TRUE, colorEdge = TRUE) 
```

```{r Paulos-igraph}
n <- 5
# sizes:
square <- 11
cricle <- 8
txt <- .7

temp_ <- fgseaRes_TFT$`Basal_1` %>% filter(padj < 0.05)
temp_ <- fgseaRes$Basal_1 %>% filter(padj < 0.05)
DGE_i <- DEGs_table %>% filter(layers == "Basal") %>% select(gene, avg_log2FC, p_val, p_val_adj, Regulation)
i_graph <- function(temp_, DGE_i, n, square, cricle){
  temp <- temp_$leadingEdge
  # names(temp) <- stringi::stri_extract(temp_$pathway, regex = "[^_]+(?=_)")
  names(temp) <- temp_$pathway
  temp2 <- lapply( names(temp) , function(x){ rep(x,length(temp[[x]])) })
  temp <- tibble("from"=unlist(temp2),"to"=unlist(temp), "gene"=unlist(temp))
  temp <- left_join(temp, DGE_i, by=c("to"="gene"))
  temp <- filter(temp, p_val < 0.005)
  g <- graph_from_data_frame(temp,directed = F)
  v_shape <- ifelse( names(V(g)) %in% temp_$pathway , "square" , "circle" )
  v_color <- ifelse( names(V(g)) %in% temp_$pathway , "honeydew" , "cornsilk" )
  v_size <- ifelse( names(V(g)) %in% temp_$pathway , square , cricle ) 
  return(list(g=g, v_shape=v_shape, v_color=v_color, v_size=v_size))}

igraph <- i_graph(temp_, DGE_i, n, square, cricle)

readouts <- temp_ %>% select(pathway, leadingEdge) %>% unnest(leadingEdge) %>% mutate(value = 1) %>% pivot_wider(names_from = leadingEdge, values_from = value, values_fill = 0) %>% column_to_rownames(., var = "pathway") %>% as.matrix()

library(enrichplot)
pairwise_termsim(temp_)
s_matrix <- enrichplot::get_similarity_matrix(temp_, set_names(temp_$leadingEdge, temp_$pathway) )
igraph$s <- graph_from_adjacency_matrix(s_matrix, mode = "undirected")
  
# Save plot
pdf(paste0(result_dir, "TFT_network", ".pdf"), width = 9, height = 9)

map2(list(igraph), list("Basal"),
     ~with(.x, 
             plot.igraph(g, label=V(g), main = paste0(.y, " regulated genes"),
             layout=layout_with_kk(g), vertex.label.color="black" ,
             vertex.size=v_size, vertex.label.cex=txt , vertex.label.font=2, 
             vertex.shape=v_shape, vertex.color=v_color,
             vertex.frame.color="grey60" , curved=F )
) )
dev.off() 

```

```{r}
library(ggraph)
library(tidygraph)
library(igraph)
# https://mr.schochastics.net/material/netVizR/
# 'graphopt', 'stress', 'kk', 'mds', 'lgl', 'backbone', 
G <- as_tbl_graph(igraph$g)
G <- as_tbl_graph(igraph$s)
# l <- layout_with_fr(G)

t <- as_tibble(G)
G_ <- G %>%
  #mutate(type = ifelse(grepl("_", t$name), "term", "gene")) %>%
  mutate(centrality = centrality_authority()) %>% 
  mutate(coreness = node_coreness(mode = 'all')) %>%
  #filter(coreness > 6) %>%
  mutate(group = as.factor(group_louvain())) #%>%
  #activate(edges) %>%
  # filter(p_val < 0.01) %>%
  activate(nodes)


layout_go <- layout_with_fr(G_)
(p <- G %>%
  ggraph(layout = 'kk') +
  geom_edge_fan(width = .3, color = 'gray') +
  # geom_polygon(
  #              aes(#x = layout_go[, 1],
  #                  #y = layout_go[, 2],
  #                    color = group),
  #              alpha = 0.3,
  #              show.legend = FALSE) +
  # ggforce::geom_mark_hull(aes(x = layout_go[, 1],
  #                    y = layout_go[, 2],
  #                    color = group)) +
  geom_node_point(aes(color=coreness), size = 3) + # , shape=type
  scale_color_viridis()
)
```

Out of `r sig_uniq` unique significant terms, `r IGG` contained IGKC, IGHA1, and IGHA2 in their gene set. The lower intermediate and the superficial layer had the most significant terms, 86 and 42 respectively.

```{r add-info-to-fgsea-table}
############################
# GESA TABLE INFO FUNCTION #
############################
# gene_rank_df <- gene_rank_df[["Basal_1"]]
# fgseaRes <- fgseaRes[[6]]
# top_n <- 20
GSEA_table.fun <- function(fgseaRes, gene_rank_df, p_adj=1){
  f <- fgseaRes  %>% # df <- fgseaRes[["Basal_1"]] %>%
    filter(padj < p_adj) %>%
    #top_n(-pval, n = top_n) %>%
    mutate(overlap = map_dbl(leadingEdge, ~length(.x)), .after = "size") %>%
    mutate(GeneRatio = map_int(leadingEdge, ~length(.x))/.$size, .after = "overlap") %>%
    unnest(leadingEdge) %>%
    left_join(., dplyr::select(gene_rank_df, gene, avg_log2FC), by=c("leadingEdge" = "gene")) %>% # gene_rank_df$Sup_1
    mutate(., dir = ifelse(.$avg_log2FC < 0, "down", "up")) %>%
    group_by(pathway) %>% 
    mutate(min_logFC = min(avg_log2FC, na.rm = T)) %>%
    mutate(max_logFC = max(avg_log2FC, na.rm = T)) %>% 
    add_count(., dir) %>%
    ungroup() %>%
    dplyr::select(pathway, overlap, GeneRatio, dir, n, min_logFC, max_logFC) %>%
    unique() %>% #filter(pathway == "GO_PEPTIDE_CROSS_LINKING")
    pivot_wider(.,  names_from = dir, values_from = n)
  
  f_ <- fgseaRes %>% # f_ <- fgseaRes[["Basal_1"]] %>%
    left_join(., f, by="pathway") %>%
    mutate(Direction = ifelse(NES > 0, "up", "down")) %>%
    mutate(dir = ifelse(is.na(.$down) & is.na(.$up), NA,
                        ifelse(is.na(.$up), "down",
                          ifelse(is.na(.$down), "up",
                                 ifelse(abs(.$down - .$up)<=3, .$Direction,
                                        ifelse(.$up > .$down, "up", "down")))))) %>%
    mutate(dir = ifelse(.$dir == "up" & max_logFC < 0.1, .$Direction, .$dir)) %>%
    mutate(dir = ifelse(.$dir == "down" & min_logFC > -0.1, .$Direction, .$dir)) %>%
    mutate(dir = ifelse(abs(min_logFC) < 0.1 &  max_logFC < 0.1, .$Direction, .$dir )) %>%
    select(-leadingEdge, leadingEdge)
  return(f_)
}
```

```{r save-GESA-results, results='hide'}
epi_clus <- "Sup_0|Sup_1|Sup_2|Intrmed|Basal_2|Basal_1"
l <- c("Sup_1", "Sup_2","Basal_1", "Basal_2",  "0", "1", "2", "3", "4", "8" )
db <- c(rep("GO", length(fgseaRes)/2),rep("KEGG", length(fgseaRes)/2))

ridge_plots <- tibble(Clusters=factor(names(fgseaRes), levels = l),
                      db = db,
                      fgseaRes = fgseaRes) %>% arrange(Clusters)

############
# ADD INFO #
############
tab <- ridge_plots %>%
  mutate(fgseaRes = pmap(., ~filter(..3, padj < 0.05))) %>%
  mutate(tab = pmap(., ~GSEA_table.fun(fgseaRes=..3, gene_rank_df[[..1]]))) %>%
  {. ->> tab_} %>%
  mutate(tab = map(tab, ~split(.x, .x$dir))) %>%
  unnest(c(tab)) %>%
  mutate(dir = names(tab)) %>%
  mutate(morf = ifelse(grepl(epi_clus, .$Clusters), "epi", "SubMuc")) %>%
  mutate(tab = set_names(.$tab, paste0(.data[["Clusters"]],"_",.data[["dir"]]))) %>%
  select(db, tab, morf) %>%
  group_by(morf, db) %>%
  summarise(tab = list(tab), .groups = "drop")

##############
# SAVE TABLE #
##############
pmap(tab, ~write.xlsx(..3, keepNA=TRUE, na.string="NA", overwrite=TRUE,
                             file=paste0(result_dir,"GESA_test_",..1,"_",..2,".xlsx"))) 
# saveRDS(tab, paste0(result_dir,"Enrichment_tables.RDS"))
# tab <- readRDS(paste0(result_dir,"fgseaRes_filt_tables.0.75.RDS"))
# tab <- tab_ %>% mutate(tab = set_names(.$tab, paste0(.data[["Clusters"]]))) %>% .$tab %>% discard(., ~nrow(.) == 0) %>% bind_rows(., .id = "clus")


```

```{r stats-epi-layers}
# Significant terms
fgseaRes_epi <- tab$tab[[3]] %>% bind_rows(., .id = "layer") %>% 
  filter(padj < 0.05) 
# Unique significant terms
sig_uniq <- fgseaRes_epi %>%
  pull(.,"pathway") %>% unique()
# Number of unique terms containing immunoglobulin genes
IGG <- fgseaRes_epi %>%
  filter(grepl('IGKC', .$leadingEdge) & grepl('IGHA', .$leadingEdge) & grepl('IGL', .$leadingEdge)) %>%
  pull(.,"pathway") %>% unique()

IGG <- fgseaRes_epi %>%
  filter(!(grepl('SPRR', .$leadingEdge) | grepl('RPS21|RPLP1', .$leadingEdge) | grepl('IGHA', .$leadingEdge))) %>%
  pull(.,"pathway") %>% unique()

# Terms not containing immunoglobulin genes
non_IGG_basal1 <- fgseaRes_epi %>%
  filter(!(grepl('IGKC', .$leadingEdge) & grepl('IGHA1', .$leadingEdge) & grepl('IGHA2', .$leadingEdge))) %>%
  filter(layer == "Basal_1") %>%
  #filter(layer != "Basal_1") %>%
  pull(.,"pathway") %>% unique()

non_IGG_notbasal1 <- fgseaRes_epi %>%
  filter(!(grepl('IGKC', .$leadingEdge) & grepl('IGHA1', .$leadingEdge) & grepl('IGHA2', .$leadingEdge))) %>%
  filter(layer != "Basal_1") %>%
  #filter(layer != "Basal_1") %>%
  pull(.,"pathway") %>% unique()

setdiff(non_IGG_basal1, non_IGG_notbasal1)
setdiff(non_IGG_notbasal1, non_IGG_basal1)
intersect(non_IGG_notbasal1, non_IGG_basal1)

fgseaRes_Basal_2 <- fgseaRes["Basal_2"] %>% bind_rows() %>% 
  filter(padj < 0.05)
```

### Split violin plots of genes in GO terms of intrest

```{r 07a_violin_plots, fig.height=8*3, eval=FALSE}
# dev.new(width=6.6929133858, height=5*3, noRStudioGD = TRUE)
######################
# GENES IN GESA TERM #
#####################
terms <- c("GO_KERATINOCYTE_DIFFERENTIATION", "GO_PEPTIDE_CROSS_LINKING", "GO_SKIN_DEVELOPMENT", "GO_B_CELL_MEDIATED_IMMUNITY")
           #, "GO_RESPONSE_TO_ESTRADIOL")
# term <- "GO_PEPTIDE_CROSS_LINKING"
terms.fun <- function(tab, term){
  term_genes <- tab %>%
    unnest(c(tab)) %>%
    mutate(clus = str_replace(names(.$tab), "_down|_up", "") ) %>%
    unnest(c(tab)) %>%
    filter(pathway == term & morf == "epi") %>%
    mutate(clus_all = paste(unique(.$clus), collapse = "$|^")) %>%
    arrange(desc(overlap)) %>%
    #filter(overlap == max(overlap)) %>%
    reframe(genes = unique(unlist(.$leadingEdge)), clus = .$clus[1], clus_all = .$clus_all[1]) %>%
    #mutate( genes = factor(.$genes, levels = gene_rank_df[[.$clus[1]]]$gene)) %>%
    nest(genes = c(1))
    
  return(term_genes)
}

term_genes <- terms %>%
  map(., ~terms.fun(tab, .x)) %>% 
  list_rbind() %>%
  mutate(term = terms)

################
# VIOLIN PLOTS #
################
violin_split.fun <- function(obj, gene_list, split.by, group.by, filt_pattern){
  obj <- filter(obj, grepl(filt_pattern, obj$layers))
  plots <- VlnPlot(obj, features = gene_list, adjust = 1/2, cols =  c("#BFDFEE", "#DD868F"),
                   split.by = split.by, group.by = group.by, 
                   pt.size = 0, combine = FALSE, split.plot = TRUE) 
  plots <- map(plots, ~.x + geom_point(alpha = .3, size=.1, show.legend = F,
                                       position = position_jitterdodge(jitter.width=.5)) +
                 #scale_fill_manual(values = c("#88CCEE", "#CC6677")) +
                 #scale_color_manual(values = c("#88CCEE", "#CC6677")) +
                 theme(axis.title.x = element_blank()))
  p <- wrap_plots(plots, ncol = 10) + plot_layout(guides = "collect")
  h <- round(length(plots)/10)*4
return(tibble(plot=list(p), height = list(h), p = list(plots)))
}

plots <- term_genes %>%
  mutate(genes = map(genes, ~arrange(.x, genes))) %>%
  mutate(genes = map(genes, ~unlist(.x))) %>%
  pmap(., ~violin_split.fun(DATA, ..3, "groups", "layers", ..2)) %>%
  list_rbind() %>%
  mutate(term = terms)

pmap(plots, ~ggsave(paste0("./Figures/07/","DEGs_",..4,".png"), plot=..1, width = 40, height = ..2))

wrap_plots(plots[["p"]][[2]], ncol = 3) + plot_layout(guides = "collect")
```

```{r 07b_GSEA_rank_plot, fig.width=12 }
# dev.new(width=12, height=3, noRStudioGD = TRUE)
# width = aspect * height 4.857143
# height = width/aspect 10/4.857143
###########################
# GESA RANK PLOT FUNCTION #
###########################
plot_GseaTable.fun <- function(db, fgseaRes, gene_rank_list, n = 10, padj = 0.05){
    if(db == "GO"){database <- GO_database}else{database <- KEGG_database}
    
    #fgseaRes <- mutate(fgseaRes, pathway = formating_str.fun(fgseaRes$pathway))
  
    topPathwaysUp <- fgseaRes[fgseaRes$ES > 0 & fgseaRes$padj < padj,]
    topPathwaysDown <- fgseaRes[fgseaRes$ES < 0 & fgseaRes$padj < padj,]
    
    topPathwaysUp <- unlist(topPathwaysUp[head(order(topPathwaysUp$pval), n=n), "pathway"])
    topPathwaysDown <- unlist(topPathwaysDown[head(order(topPathwaysDown$pval), n=n), "pathway"])
  
    p <- plotGseaTable(database[c(topPathwaysUp, rev(topPathwaysDown))], 
                  gene_rank_list, fgseaRes, gseaParam = 0.5, render=F)
    return(tibble(rank_plots=list(p), n_pathways = length(topPathwaysUp) +length(topPathwaysDown)))  # tibble(plots=list(plot), df=list(f))
    }

############
# PLOTTING #
############
db <- c(rep("GO", length(fgseaRes)/2),rep("KEGG", length(fgseaRes)/2))
ridge_plots <- tibble(Clusters=names(fgseaRes),db = db,fgseaRes = fgseaRes) 

plots_df <- pmap_dfr(ridge_plots,
              ~plot_GseaTable.fun(db=..2, fgseaRes=..3, gene_rank_list[[..1]], n = 30) ) %>%
  bind_cols(ridge_plots, .) %>%
  mutate(rank_plots = setNames(.[["rank_plots"]], .$Clusters)) %>%
  filter(n_pathways > 0)

##################
# SAVE GESA PLOT #
##################
if( isFALSE(dir.exists("./Figures/07/GO/")) ) { dir.create("./Figures/07/GO/",recursive = TRUE) }
if( isFALSE(dir.exists("./Figures/07/KEGG/")) ) { dir.create("./Figures/07/KEGG/",recursive = TRUE) }

pmap(plots_df, ~ggsave(paste0("./Figures/07/",..2,"/GSEA_rank_plot_", ..1,"_",..2, ".png"), #"GO_filt/",
                          plot=..4, width = 13, height = (..5*.3)+2 ))

grid::grid.draw(plots_df$rank_plots$`1`)
```

```{r}
# library(enrichplot)
# res_epi <- list(fgseaRes$Sup_1, fgseaRes$Sup_2, fgseaRes$Basal_2, fgseaRes$Basal_1) %>% set_names(., l[1:4])
# dot_df <- bind_rows(res_epi, .id = "layer") %>%
#   mutate(pathway = formating_str.fun(.$pathway)) %>%
#   filter(!(is.na(.$pathway))) %>%
#   filter(padj < 0.05) %>%
#   mutate(layer = factor(.$layer, levels = l[1:4])) %>%
#   mutate(type = ifelse(.$NES < 0, "downregulated", "upregulated")) %>%
#   group_by(type, layer) %>%
#   top_n(10, abs(NES)) %>%
#   ungroup(.) %>%
#   mutate(GeneRatio = map_int(.$leadingEdge, ~length(.x))/.$size) 
# 
# ## from Tommy's code
# p <- ggplot(dot_df, aes(x = GeneRatio, y = fct_reorder2(pathway, GeneRatio, type))) + 
#                geom_point(aes(size = size, color = padj)) +
#                theme_bw(base_size = 14) +
#         scale_colour_gradientn(limits=c(0, 0.05), colours = c("#E41A1C","#FF7F00","#C77CFF","#984EA3")) +
#         ylab(NULL) + scale_x_continuous(expand = c(.02, .02)) + #xlim(c(0, 0.5)) +
#         ggtitle("GO pathway enrichment")
# 
# (p + facet_grid(.~layer + type))
# 
# 
# dotplot(fgseaRes$Sup_2, showCategory=30) + ggtitle("dotplot for GSEA")

```

```{r format-string-function}
############################
# STRING FRMATING FUNCTION #
############################
formating_str.fun <- function(terms){
  terms <- gsub("_", " ", terms)
  terms <- gsub("(GO |KEGG )|(\\w+)", "\\1\\L\\2", terms, perl = TRUE)
  terms <- gsub("endoplasmic reticulum", "ER", terms, perl = TRUE)
  #terms <- str_replace(terms, "(.{28,}?)\\s", "\\1\n")
  #genes <- unlist(lapply(res_list,function(x){ x$genes [1:N] }))
  #genes[is.na(genes)] <- ""
  return(terms)
}
#terms <- "GO humoral immune response mediated by circulating immunoglobulin pla"
```

```{r GeneRatio_plot_per_cluster}
#################################
# GESA GENE RATIO PLOT FUNCTION #
################################
GeneRatio_plot.fun <- function(fgsea_df, txt_size = 15, reg = "up|down", nr_path=10,
                               col=rev(c("#e31a1c","#fd8d3c","#fecc5c","#ffffb2"))){
  dot_df <- fgsea_df %>% # df<- GR_plots[["fgseaRes"]][[10]] %>%
    mutate(pathway = formating_str.fun(.$pathway)) %>%
    filter(!(is.na(.$pathway))) %>%
    filter(padj < 0.05) %>%
    mutate(layer = factor(.$layer, levels = l[5:9])) %>%
    mutate(GeneRatio = map_int(.$leadingEdge, ~length(.x))/.$size) %>%
    filter(grepl(reg, .$dir))
  
  pathways <- dot_df %>% group_by(layer) %>% top_n(., nr_path, abs(NES)) %>% pull(., "pathway")
  dot_df <- dot_df %>%
    filter(pathway %in% pathways)
  
  p <- ggplot(dot_df, aes(x = layer, y = fct_reorder(pathway, GeneRatio))) + 
                 geom_point(aes(size = padj, color = GeneRatio)) + # ,lineheight = 0.5
                 theme_bw(base_size = 14) +
          #scale_y_discrete(labels = function(x) str_wrap(x, width = 35)) +
          #scale_size_continuous(breaks = c(.25, .50, .75, 1), limits = c(0,1)) +
          #scale_colour_gradientn(limits=c(0, 0.05), colours = col) +
          scale_colour_gradientn(limits=c(0, 1), colours = col) +
          ylab(NULL) + 
          # scale_x_continuous(expand = c(.02, .02), n.breaks = 3) + #xlim(c(0, 0.5)) +
          ggtitle(paste0("GO pathway enrichment epithelium"), ) +
          theme(plot.title = element_text(hjust = 1, size = txt_size-1.5),
                plot.margin =  unit(c(.1,.2,.1,0), "cm"), # trbl
                legend.spacing = unit(0, "lines"),
                #text = element_text(size = txt_size),
                axis.title.x = element_text(size = txt_size-2),
                axis.text.y = element_text(lineheight = 0.7)) +
    facet_grid(n ~ factor(layer, levels = l), scales="free", space = "free") +
    
    theme(text = element_text(size = 15),
          strip.background =   element_blank(), # removes facet labels
          strip.text.x =       element_blank()) # removes facet labels)
  return(p)
}

########################
# GESA GENE RATIO PLOT #
########################
db <- c(rep("GO", length(fgseaRes)/2),rep("KEGG", length(fgseaRes)/2))
ridge_plots <- tibble(Clusters=names(fgseaRes),db = db, fgseaRes = fgseaRes)

l <- c("Sup_1", "Sup_2","Basal_1", "Basal_2", "8", "3", "4","0", "1", "2"  )
ridge_plots <- tibble(Clusters=fct_relevel(names(fgseaRes), l), 
                      db = db, fgseaRes = fgseaRes) %>% 
  mutate(fgseaRes = pmap(., ~filter(..3, padj < 0.05))) %>%
  filter(., map_vec(.$fgseaRes, ~nrow(.x) != 0)) %>%
  mutate(fgseaRes = pmap(., ~GSEA_table.fun(fgseaRes=..3, gene_rank_df[[..1]]) ))

# col <- c("#E41A1C","#FF7F00","#C77CFF","#984EA3")
GR_plots <- ridge_plots %>%
  arrange(db, Clusters) %>%
  mutate(fgseaRes = pmap(., ~mutate(..3, layer = ..1))) %>% 
  mutate(plot_up = pmap(., ~GeneRatio_plot.fun(..3, txt_size = 12, reg = "up"))) %>%
  mutate(plot_down = pmap(., ~GeneRatio_plot.fun(..3, txt_size = 12, reg = "down"))) %>%
  mutate(plot = pmap(., ~GeneRatio_plot.fun(..3, txt_size = 12)))

c <- c("#fde725","#5ec962","#21918c","#3b528b","#440154")
c <- c("#f0f921","#f89540","#cc4778","#7e03a8","#0d0887")
(GR_plots <- ridge_plots[5:9,] %>%  # [1:4,]
  mutate(fgseaRes = set_names(.$fgseaRes, paste0(.data[["Clusters"]]))) %>% 
  .$fgseaRes %>%
  bind_rows(., .id="layer") %>%
    filter(padj < 0.05) %>%
  mutate(n = n(), .by="pathway") %>%
  mutate(n = factor(n, levels=rev(1:length(unique(.$layer))))) %>%
  GeneRatio_plot.fun(., txt_size = 12, reg = "up|down", nr_path=15, col = c))
```

```{r 07c_GESA_rank_plot_epi_down, fig.height=5.5, fig.width=10.07, dev=c('png','pdf')}
# dev.new(width=10.08, height=5.5, noRStudioGD = TRUE)
######################
# GESA RANK PLOT EPI #
######################
(patch <- wrap_plots(GR_plots$plot_down[1:4]) + plot_layout(guides = "collect", ncol = 2))
#(patch <- wrap_plots(GR_plots$plot[6:9]) + plot_layout(guides = "collect", ncol = 2))
#ggsave("./Figures/07/GESA_rank_plot_epi_down.png", plot = patch, width = 10.07, height = 5.5, units = "in", dpi = 300)
```

```{r 07d_GESA_rank_plot_epi_up, fig.height=5.5, fig.width=17.4, dev=c('png','pdf')}
# dev.new(width=17.3, height=5.5, noRStudioGD = TRUE)
######################
# GESA RANK PLOT EPI #
######################
(patch <- wrap_plots(GR_plots$plot_up[1:4]) + plot_layout(guides = "collect", ncol = 2))
#ggsave("./Figures/07/GESA_rank_plot_epi_up.png", plot = patch, width = 17.4, height = 5.5, units = "in", dpi = 300)
```

```{r 07e_GESA_rank_plot_SubMuc_down, fig.height=8.25, fig.width=12.4, dev=c('png','pdf')}
# dev.new(width=12.4, height=8.25, noRStudioGD = TRUE)
############################
# GESA RANK PLOT SUBMUCOSA #
############################
wrap_plots(GR_plots$plot_down[5:9]) + plot_layout(guides = "collect", ncol = 2) 
```

```{r 07f_GESA_rank_plot_SubMuc_up, fig.height=8.25, fig.width=13, dev=c('png','pdf')}
# dev.new(width=13, height=8.25, noRStudioGD = TRUE)
############################
# GESA RANK PLOT SUBMUCOSA #
############################
wrap_plots(GR_plots$plot_up[5:9]) + plot_layout(guides = "collect", ncol = 2) 
```

```{r 07g_GESA_rank_plot_KEGG, fig.height=8.25, fig.width=10}
# dev.new(width=10, height=8.25, noRStudioGD = TRUE)
############################
# GESA RANK PLOT SUBMUCOSA #
############################
wrap_plots(GR_plots$plot[10:15]) + plot_layout(guides = "collect", ncol = 2) 
```

```{r, include=FALSE, eval=FALSE}
require(UpSetR) 
# https://cran.r-project.org/web/packages/UpSetR/vignettes/basic.usage.html 

enrich.list <- top_n(dot_df, 10, abs(NES)) 
enrich.list <- set_names(enrich.list$leadingEdge, enrich.list$pathway)
  

(upset.plot.dap.method <- UpSetR::upset(fromList(enrich.list), 
                                        order.by = "freq", 
                                        nsets = 10,
                                        keep.order = TRUE, 
                                        sets.bar.color = c("#EFEDF5", "#DADAEB", "#BCBDDC", "#9E9AC8", "#807DBA", "#6A51A3", "#54278F", "#3F007D","#56B4E9","#3F007D"),
                                        mainbar.y.label = "Differential Abundant Genes (DEGs)", 
                                        sets.x.label = "Genes in pathway"))

queries = list(
  list(
    query = elements,
    params = list("physicalActivityPerMonth", 0,4),
    color = "#Df5286", 
    active = T,
    query.name = "Physically Active 1x/Week or Less"
  )


```

### Heatmap of bulk deconvolution

```{r 04f_Heatmap, fig.width = 3, fig.height = 3, fig.dim = c(33, 33), eval=FALSE}
#install_github("jokergoo/ComplexHeatmap")
library(ComplexHeatmap)
library(circlize)
#################
# COLOUR PALLET #
#################
col.pal <- function(df, col, n) {
          lable <- seq(max(df, na.rm = T), min(df, na.rm = T), length = n)
          #lable <- append(lable, 0, after = pos)
          col <- colorRampPalette(c(col))(n)
          #col <- brewer.pal(n=n, name=pal)
          #col <- append(col, "white", after = pos)
          col_fun = colorRamp2(lable, col)
}

# Colour pallet:
# lable <- seq(max(zscore), min(zscore), length = 8)
# lable <- append(lable, 0, after = 4)
# col <- brewer.pal(n=8, name="RdYlBu")
# col <- append(col, "white", after = 4)
# col_fun = colorRamp2(lable, col)
ptc_ss <- rev(c("#364B9A", "#4A7BB7", "#6EA6CD", "#98CAE1", "#C2E4EF", "#EAECCC", "#FEDA8B", "#FDB366", "#F67E4B", "#DD3D2D", "#A50026"))
clus_col <- c("#E41A1C","#FF7F00", "#C77CFF","#984EA3") %>% purrr::set_names(., c("Sup_1", "Sup_2", "Basal_2", "Basal_1"))

##########
# MATRIX #
##########
keep <- "Sup_0|Sup_1|Sup_2|Intrmed|Basal_2|Basal_1"
d <- DEGs_table %>% filter(grepl(keep, .$layers)) %>% 
  select( gene, p_val, p_val_adj, avg_log2FC) %>%
  #filter(gene == "IGLC3") %>%
  #mutate(n = n(), .by="gene") 
  filter(n()==1 | n()>1 & p_val==min(p_val), .by="gene") %>% # filter duplicate genes 
  filter(!(duplicated(p_val)), .by="gene") # filter ties of duplicates

expand_column.fun <- function(df, col_name, id_cols){
  df_ <- df %>%
    pivot_wider(., id_cols=all_of(id_cols), names_from = col_name, 
                values_from = col_name, values_fn = ~"1", values_fill = NA )
    
  df_comb <- left_join(df, df_, by=id_cols)
  return(df_comb)
}

tab <- tab_ %>% 
  filter(!(db == "KEGG")) %>%
  mutate(tab = set_names(.$tab, paste0(.data[["Clusters"]]))) %>%
  .$tab %>%
  keep(., ~nrow(.) > 0) %>%
  bind_rows(., .id="clus")

matrix <- tab %>%
  filter(grepl(keep, .$clus)) %>%
  mutate("Sig. in" = paste0(.$clus[cur_group_rows()], collapse = "|"), .by="pathway") %>%
  mutate(c = .$clus) %>%
  expand_column.fun(df=., col_name="c", id_cols=c("Sig. in","pathway")) %>%
  filter(n()==1 | n()>1 & pval==min(pval), .by="pathway") %>%
  dplyr::select(clus, pathway, gene="leadingEdge", padj, ES, NES, overlap, GeneRatio, "Sig. in", Sup_1:Basal_2) %>%
  unnest(gene) %>%
  
  left_join(., d, by="gene") %>%
  filter(p_val < 0.001) %>%
  {. ->> annot} %>%
  select(gene, pathway) %>%
  mutate(val = 1) %>%
  # dplyr::group_by(pathway, gene) %>%
  # dplyr::summarise(n = dplyr::n(), .groups = "drop") %>%
  # dplyr::filter(n > 1L) 
  pivot_wider(., names_from = "gene", values_from = "val", values_fill = 0) %>%
  
  column_to_rownames(var = "pathway") %>%
  as.matrix()

##############
# ANNOTATION #
##############
annot_col <- annot %>%
  select(gene, p_val, "avg log2FC"=avg_log2FC) %>%
  unique() %>%
  column_to_rownames(var = "gene") %>%
  mutate("-log10(p val)" = -log10(p_val)) %>%
  mutate(row_sum = colSums(matrix)) %>%
  mutate(row_id = cur_group_rows())

annot_row <- annot %>%
  select(pathway, Sup_1:Basal_2) %>%
  unique() %>%
  column_to_rownames(var = "pathway") %>%
  mutate(row_sum = rowSums(matrix)) %>%
  mutate(row_id = cur_group_rows())

annot.fun <- function(annot_row, annot_col){
anno_row <- rowAnnotation(
  "Sup_1" = annot_row$Sup_1,
  "Sup_2" = annot_row$Sup_2,
  "Basal_1" = annot_row$Basal_1,
  "Basal_2" = annot_row$Basal_2,
  na_col = "white",
  show_legend = FALSE,
  col = list("Sup_1" = c("1"="#E41A1C"),
             "Sup_2" = c("1"="#FF7F00"),
             "Basal_2" = c("1"="#C77CFF"),
             "Basal_1" = c("1"="#984EA3")) )

anno_col <- annot_col %>%
  HeatmapAnnotation(df = .,
                    col = list(
                      "-log10(p val)" = col.pal(annot_col$`-log10(p val)`, c("#e68633","#f9e9d3"), 5),
                      "avg log2FC" = col.pal(annot_col$`avg log2FC`, ptc_ss, 5)
                             ))
return(list(anno_row=anno_row, anno_col=anno_col))
}
#colorRamp2(seq(0, 2, length.out=length(ptc_ss)), ptc_ss) strcture(ptc_ss) ptc_rnbwdcolorRamp2(c(0, 1, 2), c("blue", "white", "red"))
dim(matrix)
dim(annot_row)
dim(annot_col)
#################
# PLOT HEATMAP #
################

# Clustering
# define k clusters 

k_row <- 9
k_col <- 6

heatmap.fun <- function(mat, anno_col, anno_row, k_row, k_col){
  H <- Heatmap(mat, 
               show_heatmap_legend = FALSE,
               #row_split = 6, column_split = 7, # hierarchical
               row_km = k_row, column_km = k_col, # kmeans
               col = c("#f9e1e6","#e4465d"),
               top_annotation = anno_col,
               left_annotation = anno_row,
               show_column_names = T,
               show_row_names = T,
               #clustering_distance_rows= "spearman",
               clustering_distance_columns=  "spearman",
               column_names_gp = grid::gpar(fontsize = 7),
               row_names_gp = grid::gpar(fontsize = 5),
               column_names_rot = 47,
               #direction = "horizontal"
               #heatmap_legend_param = list(
                 #title = "Cell proportion \n(scaled)"
                 #at = c(-4,-2,0,2, 4), 
                 #labels = c("0.4%", "0.3%", "0.2%", "0.1%", "0%")
  )
  set.seed(123)
  HM <- draw(H, annotation_legend_side = "left")
  return(HM)
}
# dev.new(width=10, height=10, noRStudioGD = TRUE)
anno <- annot.fun(annot_row, annot_col)
HM <- heatmap.fun(matrix, anno$anno_col, anno$anno_row, 20, 20)

###########################
# HIERARCHICAL CLUSTERING # 
###########################
# of genes (rows) and samples (columns) 'outside' ComplexHeatmap

hr <- hclust(dist(matrix, method = "euclidean"), method="complete") 
hc <- hclust(dist(t(matrix), method = "euclidean"), method="complete")

annot_col$k_clus <- kmeans(hc, centers = k_col)$cluster 
annot_col$h_clus <- cutree(hc, k=k_col)

# get clusters from HM object
get_clustering.fun <- function(annot_df, CH, row = T){
  if(row==TRUE){
    l <- CH@ht_list[[1]]@row_order_list
    lab <- CH@ht_list[[1]]@row_names_param[["labels"]]
  }else{l <- CH@ht_list[[1]]@column_order_list
        lab <- CH@ht_list[[1]]@column_names_param[["labels"]]}
  #l <- purrr::set_names(unlist(l), unlist(imap(l, ~rep(.y, length(.x)))))
  l <- purrr::set_names(lab, unlist(imap(l, ~rep(.y, length(.x)))))
  clus <- map_chr(rownames(annot_df), ~names(l)[which(l == as.character(.x))])
  return(clus)
}

annot_col <- mutate(annot_col, k_clus = get_clustering.fun(annot_col, HM, row=F)) 
annot_row <- mutate(annot_row, k_clus = get_clustering.fun(annot_row, HM, row=T)) 

#############################
# REMOVE UNINERESTING GENES # 
#############################
keep <- c("GO_REGULATION_OF_RESPIRATORY_BURST","GO_OXIDATION_REDUCTION_PROCESS", "GO_RESPONSE_TO_INORGANIC_SUBSTANCE")
keep <- annot$gene[annot$pathway == "GO_OXIDATION_REDUCTION_PROCESS"]
annot_colF <- annot_col %>% filter(!(grepl("^1$|^2$|^4$",.$k_clus)) & !(rownames(.) %in% keep))
annot_rowF <- annot_row %>% filter(!(grepl("^3$|^1$",.$k_clus)))

# remove highly abundant genes
annot_colF <- annot_col %>% filter(!(grepl("^19$|^12$|^11$",.$k_clus)))
annot_rowF <- annot_row %>% filter(!(grepl("^3$|^1$",.$k_clus)))

matrixF <- matrix[c(annot_rowF$row_id), c(annot_colF$row_id)]
matrixF <- matrixF[!(rowSums(matrixF) == 0), !(colSums(matrixF) == 0)]

dim(matrixF)
dim(annot_rowF)
dim(annot_colF)
###################
# RE-DRAW HEATMAP # 
###################
# dev.new(width=10, height=10, noRStudioGD = TRUE)
anno_ <- annot.fun(annot_rowF, annot_colF)
H_ <- heatmap.fun(matrixF, anno_$anno_colF, anno_$anno_rowF, 15, 20)

annot_colF <- mutate(annot_colF[colnames(matrixF),], k_clus2 = get_clustering.fun(annot_colF[colnames(matrixF),], H_, row=F)) 
annot_rowF <- mutate(annot_rowF[rownames(matrixF),], k_clus2 = get_clustering.fun(annot_rowF[rownames(matrixF),], H_, row=T)) 

png(file=paste0("./Figures/07/", "GESA_heatmap_Epi.png"), 
    width = 18,
    height = 17, units = "cm", res = 300
)
HM	
dev.off()
```

```{r 07c_GSEA_rank_plotting, fig.width=10, eval=FALSE, include=FALSE}
# \n (log2FC*log10(p_val))
# not working properly
##########################
# GESA RANK PLOT MY CODE #
##########################
# not quite finished. Missing p-val and NES values
library(scales)
db <- c(rep("GO", length(fgseaRes_GO)),rep("KEGG", length(fgseaRes_KEGG)))
GSEA_rank_plot.fun <- function(df, gene_rank_df, top_n, Cluster, n = 40){
  
  #string <- ridge_plots$fgseaRes[[1]]$pathway
  clean_string <- function(string){
    string <- gsub("_", " ", string)
    string <- gsub("(GO |KEGG )|(\\w+)", "\\1\\L\\2", string, perl = TRUE)
    string <- gsub("endoplasmic reticulum", "ER", string, perl = TRUE)
    string <- gsub("^(.{50})(.*)$", "\\1\n\\2", string) }
  
  f <- df %>%
    #filter(pathway %in% c(topPathwaysUp, rev(topPathwaysDown))) %>%
    mutate(Direction = ifelse(ES > 0, "UP", "DOWN")) %>%
    group_by(Direction) %>%
    top_n(-pval, n = 10) %>%
    # nest() %>%
    ungroup() %>%
    mutate(max_logFC = map_dbl(leadingEdge, 
                               ~max( gene_rank_df$avg_log2FC[gene_rank_df$gene %in% .x] ))) %>%
    filter(abs(max_logFC) > 0.32 ) %>%
    mutate(pathway = clean_string(.$pathway)) %>%
    unnest(leadingEdge) %>%
    left_join(., gene_rank_df, by=c("leadingEdge"="gene")) %>%
    arrange(NES) %>%
    mutate(pathway = factor(pathway, levels=unique(c(.$pathway)))) %>%
    mutate(rank = factor(as.character(rank), levels=as.character(seq_along(gene_rank_df$gene))))
  
    # lab <- tibble(pathway = "logFC", rank=as.factor(seq_along(gene_rank_list$`9`)),
    #               avg_log2FC = gene_rank_df$`9`$avg_log2FC, fill = gene_rank_df$`9`$avg_log2FC)
    # lab <- tibble(pathway = "logFC", rank=seq_along(gene_rank_list),  
    #               avg_log2FC = gene_rank_df$avg_log2FC, fill = gene_rank_df$avg_log2FC)
    # 
    # f_ <- f %>% bind_rows(., lab) %>%
    #   mutate(fill = ifelse(is.na(.$fill), .$avg_log2FC, .$fill)) %>%
    #   mutate(rank = )
  
    ma <- max(abs(f$`avg_log2FC`))
    mi <- -max(abs(f$`avg_log2FC`))

    # every_nth = function(n) {
    # return(function(x) {x[c(TRUE, rep(FALSE, n - 1))]})
    # }
    # every_nth(n = 10)
    # x <- 1:30
    # x[c(TRUE, rep(FALSE, 3))]
    #s <- as.character(seq(from=0, to=length(gene_rank_df$gene), by=4000))
    
   #### Plotting ####
   plot <- f %>%
      ggplot() +
        geom_col( aes(x=rank, y=avg_log2FC, fill=avg_log2FC )) + # guides(fill="none") +
        #geom_col( aes(x=rank, y=avg_log2FC, fill=`fill` )) + #guides(fill="none") +
        geom_text(x = Inf, y = 0, aes(label = sprintf("%.1e", pval)), data = f, size = 2.5, hjust = -.5) +
        geom_text(x = Inf, y = 0, aes(label = sprintf("%.1e", padj)), data = f, size = 2.5, hjust = -2.3) +
        geom_text(x = Inf, y = 0, aes(label = sprintf("%.2f", NES)), data = f, size = 2.5, hjust = -6.1) +
        #annotate("text", x = Inf, y = ma+1, label = "p-val") +
        scale_x_discrete(breaks = NULL, expand = expansion(mult = .01))  + labs(x=NULL) +
        # scale_fill_gradientn(colours = cols,
        #               limits = c(mi, ma),
        #               guide = guide_coloursteps(even.steps = T,
        #                                         show.limits = F),
        #               breaks = c(round(mi), 0, round(ma))
        #               ) +
        scale_fill_continuous(type = "viridis" ) +
        #scale_fill_binned(type ="viridis") +
        # scale_fill_gradientn(colours = cols, name = "avg_logFC", limits = c(mi, ma),
        #                       values = seq(from=mi, to=ma, along.with=cols),
        # #guide = guide_legend(override.aes = list(breaks=c(1, 0.5, 0.05, 0.01, 0.001)))
        # ) +
        coord_cartesian( clip = "off") +
        facet_wrap("pathway", ncol = 1, strip.position = "left") +
        labs(title = paste0('GSEA analysis Cluster ', Cluster)) +
        theme_void() +
        theme(strip.text.y.left = element_text(angle = 0, hjust = 1),
              panel.spacing.y=unit(.1, "lines"),
              legend.position="bottom",
              legend.key.width=unit(10,"mm"),
              #legend.key.width=unit(.4,"grobwidth", data = ggplotGrob(plot)),
              #strip.background =element_rect(fill="transparent"),
              axis.title.y = element_blank(),
              axis.text.x = element_text(size = 3),
              strip.background = element_blank(),
              plot.margin = unit(c(1,50,1,1), "mm") # t,r,b,l
              )
    return(tibble(plots=list(plot), df=list(f)))
    #return(plot, df=f))
  }

ridge_plots <- tibble(Clusters=names(fgseaRes),
                      db = db,
                      fgseaRes = fgseaRes) 

ridge_plots <- ridge_plots %>%
  pmap_dfr(., ~GSEA_rank_plot.fun(df=..3, gene_rank_df[[..1]], top_n=15, Cluster=..1, n = 2)) %>%
  bind_cols(ridge_plots, .) %>%
  mutate(plots = setNames(.[["plots"]], .$Clusters))
  
ridge_plots$plots[1]

pmap(ridge_plots, ~ggsave(paste0(result_dir,"GSEA_ridgeplot_", ..1,"_",..2, ".jpg"), 
                          plot=..4, width = 7, height = (length(levels(..5$pathway))*.3)+2))
ggsave(paste0("./Figures/07/","GSEA_ridgeplot", ".pdf"), width = 5, height = 5,
       gridExtra::marrangeGrob(grobs=ridge_plots$plots, ncol=1, nrow=1))
```
